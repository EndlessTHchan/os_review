[toc]



# 第一章 绪论

## 1.1 数据结构的基本概念

**数据：** 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。

**数据元素：** 是数据的基本单位，通常作为一个整体进行考虑和处理。

**数据项：** 一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。

**数据对象：** 是*具有相同性质*的数据元素的集合，是数据的一个子集。

**数据结构：** 是相互之间存在一种或多种*特定关系*的数据元素的集合。**数据结构**是计算机中存储、组织数据的方式。

## 1.2 数据结构的三要素

![](F:\learning\os_review\数据结构\assets\2616061-20230217095905584-146494323.png)

**逻辑关系：**

1. **集合结构：** 各个元素同属一个集合，别无其他关系
2. **线性结构：** 数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一的前驱；除了最后一个元素，所有元素都有唯一的后继。
3. **树形结构：** 数据元素之间是一对多的关系。
4. **图状结构：** 数据元素之间是多对多的关系。

![1740319556768](F:\learning\os_review\数据结构\assets\1740319556768.jpg)

**数据的运算：** 对于每一种特定的数据结构，定义出相应的数据操作。（例如：增删改查等）

**物理结构：** 数据在计算机内存中的实际存储方法，主要包括***顺序存储、链式存储、索引存储、散列存储***。数据的存储结构会影响存储空间分配的方便程度，会影响数据运算的速度。

1. **顺序存储**：在逻辑上相邻的元素，物理位置上也采用相邻存储方式，支持**随机存取**，占用最少的空间，缺点是只能使用相邻的一块区域，可能产生**较多的外部碎片** eg： 数组
2. **链式存储:** 借用指针来指向每个元素的物理存储位置。 能够**充分利用存储单元**，但是因为指针会带来额外的开销。
3. **索引存储：** 存储元素信息的同时，也附加了一个索引表（索引项一般用关键字或者地址），**检索速度快，但是会占用额外的存储空间**
4. **散列存储：**根据元素的**关键字运用哈希函数**直接计算出存储地址，查找，增加和删除节点很方便，但是hash函数选的不好会导致冲突

## 1.3 数据类型、抽象数据类型

**数据类型：** 是一个*值的集合*和定义在此集合上的*一组操作*的总称。

* 原子类型，其值不可再分的数据类型。（例如：bool，int）
* 结构类型，其值可以再分的数据类型。（例如：struct结构体）

**抽象数据类型（Abstract Data Type）：** 是抽象数据组织及与之相关的操作。定义一个ADT实际上就是定义一个数据结构(c++的类)。

## 1.4 算法的基本概念

**算法：** 是对特定问题求解步骤的一种描述，它是指令的有限序列。

**算法的特性：** （有一个不满足，则不称之为算法,**这是算法的本质特征**）

* 有穷性 （在有限的步骤和时间内可以得到结果）
* 确定性 （对同一个输入，必须有同一个输出）
* 可行性 （算法可以通过编程来实现）
* 输入 （有0个或多个输入）
* 输出 （有1个或多个输出）

**“好算法”的特质：**

* 正确性 （正确的求解问题）
* 可读性 （易于理解）
* 健壮性 （耐操，对非法输入能够正确的处理）
* 高效率和低存储量 （时间复杂度和空间复杂度低）

## 1.5 算法的时间复杂度

**什么是时间复杂度：** 算法的时间复杂度是一个函数，它定性的描述该算法的运行时间。

![](F:\learning\os_review\数据结构\assets\2616061-20230217095904200-1689561152.png)

* 加法规则：

  $T(n) = T_1(n) + T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n))) $

* 乘法规则：

  $T(n) = T_1(n)*T_2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)) $

**算法的时间复杂度：** $(O(1) < O(log\_2n) < O(n) < O(nlog_2n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)$

![](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905621-786343667.png)\
![](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905571-1943577834.png)

## 1.6 算法的空间复杂度

**算法原地工作：**指算法的空间复杂度为常数级。

案例：

![image-20220414151900763](F:\learning\os_review\数据结构\assets\2616061-20230217095904230-1135048513.png)\
\
![image-20220414152120057](F:\learning\os_review\数据结构\assets\2616061-20230217095905703-2001129926.png)



# 第二章 线性表

## 2.1 线性表的定义

**定义：** 线性表是*具有相同数据类型*的n个数据元素的*有限序列*，其中n为表长。

* 每个元素所占用的空间一样大

* 有限

* 只有先后次序，没有其他关系

* 仅讨论逻辑关系

Eg: 所有整数按递增次序排列是线性表吗？ 答：不是，因为不是有限。

## 2.2 顺序表

### 2.2.1 顺序表的定义

**定义:** 顺序表是指用顺序存储的方式实现线性表。

**顺序存储**指的是把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中。

如果说线性表的定义是从逻辑结构的角度出发，那么顺序表的定义就是从物理结构的角度出发。

**顺序表的特点：**

1. 随机存取，可以在$O(1)$时间内找到第$I$个元素
2. 存储密度高
3. 拓展容量不方便
4. 插入、删除操作不方便，需要移动大量元素

**补充：** 随机存取，亦称直接访问，代表同一时间访问一组序列中的一个随意元素。

### 2.2.2 顺序表的实现

![image-20220415144452026](F:\learning\os_review\数据结构\assets\2616061-20230217095905737-1744020185.png)

### 2.2.3 顺序表的插入和删除

![image-20220415150740990](F:\learning\os_review\数据结构\assets\2616061-20230217095904460-1515684174.png)\
![image-20220415150921858](F:\learning\os_review\数据结构\assets\2616061-20230217095905660-1692088262.png)

顺序表注意如何分析时间复杂度，例如插入时，删除时，**按值查找**

## 2.3 单链表

### 2.3.1 单链表的定义

**定义:** 单链表是指用链式存储的方式实现线性表。

**单链表的特点：**

1. 不要求大片的连续空间，改变容量方便。
2. 不可随机存取
3. 需要耗费空间来存储指针

### 2.3.2 单链表的初始化

**初始化单链表：** 可以分为*带头结点的单链表*和*不带头结点的单链表* 

注：头节点的优点：1.**方便运算的实现（插入删除）** 2.空表和非空表的处理得到了统一。

```c++
// 带头结点的单链表
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

bool InitList(LinkList &L) { // 初始化
	/*  (DLinklist &L)这种写法是C++的引用变量声明，虽然(DLinklist <=> DNode *) 等价，但是不能写成(DNode * &L)因为这不是合法的声明变量形式。
		(int &a)是c++中声明引用变量的方式，这里的&不表示取地址。
		如果非得写成DNode * 的格式，则必须使用双指针。
	*/
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL) {
        return false;
    }
    L -> next = NULL;
    return true;
}

bool Empty(LinkList L) { // 判空
    return (L -> next == NULL);
}
```

```c++
// 不带头结点的单链表
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

bool InitList(LinkList &L) {
    L = NULL;
    return true;
}

bool Empty(LinkList L) {
    return L == NULL;
}
```

### 2.3.3 单链表的插入

**单链表的插入操作：**可以分为前插操作和后插操作。其中后插操作比较简单，而前插操作稍微复杂一点。

**前插操作的两种实现方式：**（假设p结点为需要前插的结点）

1. 遍历单链表，找到P结点的前一个结点，对前一个结点进行后插操作
2. 创建一个新的结点，对p结点进行后插操作，然后将p结点的内容复制到新的结点中，将要插入的内容加到p结点上**（交换数据域内的数据）**。
3. 上述方式是将前插转换为后插。
4. 主要时间花费在查找节点上$O(n)$

![image-20220416090942792](F:\learning\os_review\数据结构\assets\2616061-20230217095905697-1588872873.png)

### 2.3.4 单链表的删除操作

本质是将**后继的值赋值给自身，然后删除后继**

![image-20220417102738170](F:\learning\os_review\数据结构\assets\2616061-20230217095904378-1634124911.png)

**注意：**这种方式对最后一个节点的删除操作不适用。

### 2.3.5 单链表的建立

**尾插法建立单链表：**（多需要一个尾指针用于插入）

![image-20220416103734628](F:\learning\os_review\数据结构\assets\2616061-20230217095905632-1653422934.png)

**头插法建立单链表：** 重要应用是**单链表的逆置**

![image-20220416103922289](F:\learning\os_review\数据结构\assets\2616061-20230217095905706-523711283.png)

```c
// 单链表的原地逆置操作
LinkList Reverse(LinkList l)
{
    ListNode* p;
    ListNode* s;
    p=l->next;
    s=p->next;
    l->next=NULL;
    while(p!=NULL)
    {
        p->next=l->next;
        l->next=p;
        p=s;
        if(p!=NULL)
           s=p->next;
    }
    return l;
}
```

## 2.4 双链表

### 2.4.1 双链表的初始化

**带头结点的双链表**

```c++
typedef struct DNode {
    ElemType data;
    struct DNode *prior, *next;
}DNode, *DLinklist;

bool InitDLinklist(DLinklist &L) { 
    L = (DNode *) malloc(sizeof(DNode));
    if (L == NULL) {
        return false;
    }
    L -> prior = NULL;
    L -> next = NULL;
    return true;
}

bool Empty(DLinklist L) {
    if (L -> next == NULL) {
        return true;
    }
    return false;
}

void testDLinklist() {
	DLinklist L;
    InitDLinklist(L);
}
```

### 2.4.2 双链表的插入

![image-20220417100434525](F:\learning\os_review\数据结构\assets\2616061-20230217095904349-1015888158.png)

**后插操作：**

```c++
bool InsertNextDNode(DNode *p, DNode *s) {
    if (p == NULL || s == NULL) {
        return false;
    }
    s -> next = p -> next;
    if (p -> next != NULL) { // 针对在最后一个结点插入的特殊情况。
        p -> next -> prior = s;
    }
    s -> prior = p;
    p -> next = s;
    return true;
}
```

**前插操作：**

双链表的前插操作可以充分利用双链表的特性，首先，利用前向指针找到前一个结点，然后对前一个结点执行后插操作即可。

### 2.4.3 双链表的删除

![image-20220417100434525](F:\learning\os_review\数据结构\assets\2616061-20230217095905642-1240817631.png)\
\
![image-20220417100434525](F:\learning\os_review\数据结构\assets\2616061-20230217095905700-2004646587.png)\
\
![image-20220417100434525](F:\learning\os_review\数据结构\assets\2616061-20230217095904373-371761099.png)

```c++
// 删除p结点的后继节点
bool DeleteNextDNode(DNode *p) {
    if (p == NULL) {
        return false;
    }
    DNode *q = p -> next;
    if (q == NULL) {
        return false;
    }
    p -> next = q -> next;
    if (q -> next != NULL) { // 针对删除最后一个结点的特殊情况。
        q -> next -> prior = p;
    }
    free(q);
    return true;
}

// 双链表的销毁
bool DestoryList(DLinklist &L) {
    while(L -> next != NULL) {
        DeleteNextDNode(L);
    }
    free(L);
    L = NULL;
}
```

## 2.5 循环链表

### 2.5.1 循环单链表

#### 2.5.1.1 初始化及判空

循环单链表的初始化操作和单链表的初始化操作类似，只不过单链表初始化时头结点的next指针指向NULL，而**循环单链表的头结点的next指针指向自身。**

![image-20220417140940016](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905832-2047116283.png) ![image-20220417141017311](F:\learning\os_review\数据结构\assets\2616061-20230217095905847-1710304870.png)

```c++
typedef struct LNode {
	ElemType data;
    struct LNode *next;
}LNode, *LinkList;

bool InitList(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL) {
        return false;
    }
    L -> next = L;
    return true;
}

bool Empty(LinkList L) {
    if (L -> next == L) {
        return true;
    }
    return false;
}
```

hint：注意这里是否设置**尾指针**，若不设置尾指针，在表尾插入和删除需要$O(n)$,如果有尾指针则为$O(1)$

### 2.5.2 循环双链表

#### 2.5.2.1 初始化及判空

空表时，**头节点的prior和next指针**都指向头节点本身。

![image-20220417141103724](F:\learning\os_review\数据结构\assets\2616061-20230217095904337-1462700866.png)

```c++
typedef struct DNode {
    ElemType data;
    struct DNode *prior, *next;
}DNode, *DLinklist;

bool InitDLinklist(DLinklist &L) { 
    L = (DNode *) malloc(sizeof(DNode));
    if (L == NULL) {
        return false;
    }
    L -> prior = L;
    L -> next = L;
    return true;
}

bool Empty(DLinklist L) {
    if (L -> next == L) {
        return true;
    }
    return false;
}
```

#### 2.5.2.2 插入和删除操作

在双链表的插入和删除中，我们均需要对**最后一个结点**进行特殊的处理，但是在循环双链表中，则不需要对其特殊处理

![image-20220417141646704](F:\learning\os_review\数据结构\assets\2616061-20230217095905666-1330022178.png)

```c++
bool InsertNextDNode(DNode *p, DNode *s) { // 将s结点插入到p结点之后
    s -> next = p -> next;
    s -> next -> prior = s;
    s -> prior = p;
    p -> next = s;
}
```

![image-20220417142734906](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905888-1371025196.png)

```c++
bool DeleteNextNode(DNode *p) { // 删除p结点的后继结点q
    DNode *q = p -> next;
    p -> next = q -> next;
    q -> next -> prior = p;
    free(q);
}
```

## 2.6 静态链表

### 2.6.1 静态链表的定义

**静态链表是用数组的方式实现的链表**

优点：增删操作不需要大量移动元素

缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变

适用场景：

1. 不支持指针的低级语言
2. 数据元素数量固定不变的场景

![jingtailianbiao](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095904462-247806640.jpg)

```c++
# define MaxSize 10
struct Node{
    ElemType data;
    int next;
};

void testSLinkList() {
    struct Node a[MaxSize];
    // 后续代码
}

// 另外一种等价方式
# define MaxSize 10
typedef struct Node{
    ElemType data;
    int next;
} SLinkList[MaxSize];

void testSLinkList() {
    SLinkList a;
    // 后续代码
}

// 也就是说 struct Node a[MaxSize] <==> SLinkList a;
```

### 2.6.2 静态链表的操作

![image-20220417150639012](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905838-43666990.png)

## 2.7 小结

顺序表和链表的*逻辑结构*都是线性结构，都属于线性表。但是两者的*存储结构*不同：顺序表采用顺序存储，具有随机存取和存储密度高的优点，同时也有改变容量不方便的缺点；链表采用链式存储，具有改变容量方便的优点，同时也有不可随机存取和存储密度低的缺点。

由于采用不同的存储结构，因此两者的基本操作的实现效率也有所不同：

1. 初始化：

   * 顺序表需要预分配大片连续空间，若分配空间过小则后期拓容不便，若分配空间过大则浪费内存资源
   * 链表只需分配一个头结点，之后方便拓展

2. 销毁

   * 采用静态分配的顺序表使用完之后由系统自动回收空间，采用动态分配的顺序表需要手动free
   * 链表则需要依次删除各个结点

3. 增删

   * 顺序表插入和删除元素都需要将后续元素进行移动，时间复杂度为O(n)
   * 链表插入和删除元素只需要修改指针即可，虽然时间复杂度也为O(n)，但是主要来自查找目标元素上。

4. 查找

   * 顺序表按位查找的时间复杂度为O(1)，按值查找的时间复杂度为O(n)
   * 链表按位查找和按值查找的时间复杂度均为O(n)

**当表长难以估计、经常需要增删元素时---------> 链表**

**当表长可以估计、经常需要查询元素时---------> 顺序表**

# 第三章 栈和队列

## 3.1 栈的基本概念

### 3.1.1 栈的定义

**栈**是只允许在一端进行插入和删除操作的线性表。

栈顶：允许插入和删除的一端

栈底：不允许插入和删除的一端

栈的特点：后进先出（LIFO）

### 3.1.2 栈的基本操作

![image-20220418144229978](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905799-597682027.png)

🎈Tip: n个不同元素进栈，出栈元素的不同排列的个数为$\frac{1}{n+1}C^n_{2n}$​

注意：一般来说**top指针指向的是当前的栈顶元素（初始化为top=-1)**,故在判断**栈满的条件**时应该为**$top==maxsize-1$**

存入元素时，++top，然后将元素存进去。 

弹出元素时，top--，然后将元素弹出去。

有些教材top规定为0，需要先存入然后再++，同理，弹出时需要--，再弹出，这里可 以参考王道习题P66   4-6题

栈的顺序规律，一旦入栈顺序存在，我们可以通过入栈顺序判断各种不同的出栈顺序是否合法（详细见王道p68 27-31题）

## 3.2 顺序栈

### 3.2.1 顺序栈的初始化

```c++
#define MaxSize 10
typedef struct {
	ElemType data[MaxSize];
    int top;
} SqStack;

void InitStack(SqStack &S) {  // 初始化栈顶指针
    S.top = -1;
}

bool StackEmpty(SqStack S) { // 判断栈空
    return S.top == -1;
}

void testStack() {
    SqStack S;
    InitStack(S);
}
```

### 3.2.2 进栈、出栈操作

```c++
bool Push(SqStack &S, ElemType x) {
    if (S.top == MaxSize - 1) {
        return false;
    }
    S.data[++S.top] = x;
    return true;
}

bool Pop(SqStack &S, ElemType &x) {
    if (S.top == -1) {
        return false;
    }
    x = S.data[S.top--];
    return true;
}
```

### 3.2.3 共享栈

![](F:\learning\os_review\数据结构\assets\2616061-20230217095904412-143564210.png)

top0=-1表示0号栈为空，top1=maxsize表示1号栈为空，判断栈满的方式为top1-top0=1

hint：两个top指针都指向的**栈顶元素**

## 3.3 链栈

用链式存储的栈本质上就是一个*单链表*，只不过我们要求它只能够对*头结点*进行插入和删除操作。

### 3.3.1 带头结点的链栈

```c++
typedef struct SNode {
    ElemType data;
    struct SNode *next;
} SNode, *LinkStack;

bool InitStack(LinkStack &L) { // 初始化
    L = (SNode *)malloc(sizeof(SNode));
    if (L == NULL) {
        return false;
    }
    L -> next = NULL;
    return true;
}

bool StackEmpty(LinkStack L) { // 判断栈空
    return L -> next == NULL;
}

bool Push(LinkStack &L, ElemType x) { // 进栈
    SNode *S = (SNode *)malloc(sizeof(SNode));
    if (S == NULL) {
        return false;
    }
    S -> data = x;
    S -> next = L -> next;
    L -> next = S;
    return true;
}

bool Pop(LinkStack &L, ElemType &x) { // 出栈操作
    if (StackEmpty(L)) {
        return false;
    }
    SNode *p = L -> next;
    x = p -> data;
    L -> next = p -> next;
    free(p);
    return true;
}

bool GetTop(LinkStack L, ElemType &x) { //获取栈顶元素
    if (StackEmpty(L)) {
        return false;
    }
    x = L -> next -> data;
    return true;
}
```

### 3.3.2 不带头结点的栈

```c++
typedef struct SNode {
    ElemType data;
    struct SNode *next;
} SNode, *LinkStack;

bool InitStack(LinkStack &L) {
    L = NULL;
    return true;
}

bool StackEmpty(LinkStack L) {
    return L == NULL;
}

bool Push(LinkStack &L, ElemType x) {
    SNode *S = (SNode *)malloc(sizeof(SNode));
    if (S == NULL) {
        return false;
    }
    S -> data = x;
    S -> next = L;
    L = S;
    return true;
}

bool Pop(LinkStack &L, ElemType &x) {
    if (StackEmpty(L)) {
        return false;
    }
    SNode *p = L;
    x = L -> data;
    L = L -> next;
    free(p);
    return true;
}

bool GetTop(LinkStack L, ElemType x) {
    if (StackEmpty(L)) {
        return false;
    }
    x = L -> data;
    return true;
}
```

## 3.4 栈在括号匹配中的应用

![image-20220420090435436](F:\learning\os_review\数据结构\assets\2616061-20230217095906156-2056198733.png)

注：这里算法为，**左括号类型直接入栈，且始终以栈顶的左括号类型与进入的右括号匹配，匹配成功则继续，匹配不成功则失败**

![image-20250302210528637](F:\learning\os_review\数据结构\assets\image-20250302210528637.png)

```c++
#define MaxSize 20

typedef struct {
    char data[MaxSize];
    int top;
} Stack;

void InitStack(Stack &S) {
    S.top = -1;
}

bool IsEmpty(Stack S) {
    return S.top == -1;
}

bool Push(Stack &S, char x) {
    if (S.top == MaxSize - 1) {
        return false;
    }
    S.data[++S.top] = x;
    return true;
}

bool Pop(Stack &S, char &x) {
    if (IsEmpty(S)) {
        return false;
    }
    x = S.data[S.top--];
    return true;
}

bool bracketCheck(char str[], int length) {
    Stack S;
    InitStack(S);
    for (int i = 0; i < length; ++i) {
        if (str[i] == '{' || str[i] == '(' || str[i] == '[') { // 遇到左括号就进栈
            Push(S, str[i]);
        } else {
            if (IsEmpty(S)) { // 遇到右括号，但是栈已空，说明无法匹配
                return false;
            } else { // 遇到右括号，且栈未空，弹出栈顶元素
                char temp;
                Pop(S, temp);
                if (temp == '(' && str[i] != ')') { // 如果栈顶元素和str[i]不匹配，则失败
                    return false;
                } else if (temp == '[' && str[i] != ']') { // 如果栈顶元素和str[i]不匹配，则失败
                    return false;
                } else if (temp == '{' && str[i] != '}') { // 如果栈顶元素和str[i]不匹配，则失败
                    return false;
                }
            }
        }
    }
    return IsEmpty(S); // 匹配成功
}
```

## 3.5 栈在表达式求值中的应用

* 中缀表达式：a+b+c\*d
* 后缀表达式（逆波兰式）：ab+cd\*+
* 前缀表达式（波兰式）：++ab\*cd

### 3.5.1 后缀表达式的获取与计算

![image-20220420103245223](F:\learning\os_review\数据结构\assets\2616061-20230217095905731-172685851.png)

![image-20220501092702784](F:\learning\os_review\数据结构\assets\2616061-20230217095904535-201667993.png)

![image-20220420104847765](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905939-461956398.png)
**注意，先出栈的是右操作数**

### 3.5.2 前缀表达式的获取与计算

![image-20220420104533108](F:\learning\os_review\数据结构\assets\2616061-20230217095905818-899592106.png)

![image-20220420110325288](F:\learning\os_review\数据结构\assets\2616061-20230217095904444-1565092336.png)\
**注意，先出栈的是左操作数**







### 3.5.3 中缀表达式的计算

![image-20220501094718113](F:\learning\os_review\数据结构\assets\2616061-20230217095905966-1514159969.png)

## 3.6 栈在递归中的应用

**递归**：若一个函数，**过程或者数据结构的定义中又应用了它自身**，则这个结构或者函数是递归定义的

**递归算法的思想：** 把原始问题转化成**属性相同，但规模较小**的问题。

需要满足条件：

1. 递归表达式（递归体）
2. 边界条件

典型案例：斐波那契数列，用二叉树来呈现递归调用

![image-20220502092130182](F:\learning\os_review\数据结构\assets\2616061-20230217095905843-37745035.png)

## 3.7 队列的基本概念

### 3.7.1 队列的定义

**队列**是只允许在一端进行插入，在另一端删除的*线性表*。

队列的特点：先进先出(FIFO)

### 3.7.2 队列的基本操作

![image-20220419140713747](F:\learning\os_review\数据结构\assets\2616061-20230217095904333-345182061.png)

注：队列一般来说，**队头指针指向第一个元素，队尾指针指向末尾元素的下一个位置**

## 3.8 顺序队列

### 3.8.1 顺序队列的初始化

```c++
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int front, rear;
} SqQueue;

void InitQueue(SqQueue &Q) { // 初始化
    Q -> front = 0;
    Q -> rear = 0;
}

bool QueueEmpty(SqQueue Q) { // 判空
    return Q -> front == Q -> rear;
}
```

### 3.8.2 入队、出队操作

![image-20220419142619336](F:\learning\os_review\数据结构\assets\2616061-20230217095906005-51080915.png)

当我们对队列进行入队和出队操作时，不免会出现如下图所示的情况，这样就产生了几个问题：

1. 当rear指向最后一个存储空间时(如下图b所示)，如果继续入队(假设队列未满)，此时该如何调整rear指针的指向？
2. 如何判断一个队列存满？

针对如上问题，分析如下：

1. 当rear指针指向8时，我们如果再添加元素，则此时rear指针应该指向0。针对这种需求，我们只要对rear + 1然后让其*对MaxSize取余*即可满足需要。
2. 我们在初始化队列时，确定了判断队空的条件为`front == rear`，那么当队满的时候该如何判断呢？我们规定当`rear + 1 == front`时队满，如下图d所示，不难看出此时静态数组中还有一个剩余空间，但是这种浪费是有必要的。因为如果将其存满，则`rear == front`，这就与队空的条件一致，这样做的后果就是无法区分队空和队满。

![](F:\learning\os_review\数据结构\assets\2616061-20230217095906194-321570847.jpg)

解决方案1：舍弃一个存储空间：

判断队列满的情况  **(Q.rear + 1) % MaxSize == Q.front**

队列大小：**(Q.rear + MaxSize - Q.front) % MaxSize**

```c++
bool QueueFull(SqQueue Q) { // 判满
    if ((Q.rear + 1) % MaxSize == Q.front) {
        return true;
    }
    return false;
}

bool EnQueue(SqQueue &Q, ElemType x) { // 入队操作
    if (QueueFull(Q)) {
        return false;
    }
    Q.data[Q.rear] = x;
    Q.rear = (Q.rear + 1) % MaxSize;
    return true;
}

bool DeQueue(SqQueue &Q, ElemType &x) { // 出队操作
    if (QueueEmpty(Q)) {
        return false;
    }
    x = Q.data[Q.front];
    Q.front = (Q.front + 1) % MaxSize;
    return true;
}
```

### 3.8.3 求取队列中元素的个数

```c++
int Count(SqQueue Q) { // 求取队列中元素的个数
    return (Q.rear + MaxSize - Q.front) % MaxSize;
}
```

### 3.8.4 判空、判满的其他方式

在上面的代码中，我们为了区分判空和判满的条件，不得不舍弃一个存储空间。那么有没有一种方法可以避免这种浪费呢？

答：有，且不止一个。

第一种方式，请看如下代码：

```c++
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int front, rear;
    int size; // 队列当前长度,当插入成功时size++,当删除成功时size--
} SqQueue;

void InitQueue(SqQueue &Q) { // 初始化
    Q -> front = 0;
    Q -> rear = 0;
    Q -> size = 0;
}

bool QueueEmpty(SqQueue Q) { // 判空
    if (Q.front == Q.rear && Q.size == 0) {
        return true;
    }
    return false;
}

bool QueueFull(SqQueue Q) { // 判满
    if (Q.front == Q.rear && Q.size == MaxSize) {
        return true;
    }
    return false;
}
```

第二种方式，懒得写代码了，请看图：

```c++
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int front, rear;
    bool tag;
} SqQueue;

void InitQueue(SqQueue &Q) { // 初始化
    Q -> front = 0;
    Q -> rear = 0;
    Q -> tag = 0;
}

bool QueueEmpty(SqQueue Q) { // 判空
    if (Q.front == Q.rear && Q.tag == 0) {
        return true;
    }
    return false;
}

bool QueueFull(SqQueue Q) { // 判满
    if (Q.front == Q.rear && Q.tag==1) {
        return true;
    }
    return false;
}
void EnQueue(SqQueue &Q,){   // 进入队列
    if(QueueFUll(Q))
    {
       cout<<"queue is full"<<endl;
       return;
    }
    else
    {
        tag=1;
        Q.data[rear]==e;
        rear=(rear+1)%maxsize;
        return;
    }
}

void DeQueue(SqQueue &Q,Elemtype e){   // 出队列
    if(QueueEmpty(Q))
    {
       cout<<"queue is empty"<<endl;
       return;
    }
    else
    {
        tag=0;
        Q.data[front]==e;
        front=(front+1)%maxsize;
        return;
    }
}
```



### 3.8.5 顺序队列的另一种实现方式⭐

![](F:\learning\os_review\数据结构\assets\2616061-20230217095904439-1249167160.jpg)

此时判断队空和队满的方式有了些许改变，但是也存在着浪费空间和不浪费空间的几种方法。

```c++
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int front, rear;
} SqQueue;

void InitQueue(SqQueue &Q) { // 初始化
    Q -> front = 0;
    Q -> rear = MaxSize - 1;
}

bool QueueEmpty(SqQueue Q) { // 判空
    if ((Q.rear + 1) % MaxSize == Q.front) {
        return true;
    }
    return false;
}

bool QueueFull(SqQueue Q) { // 判满
    if ((Q.rear + 2) % MaxSize == Q.front) {
        return true;
    }
    return false;
}
```

## 3.9 链式队列



用链式存储的队列本质上也是一个*单链表*，只不过我们要求它只能够**对*头结点*进行删除操作，对*尾结点*进行插入操作**。

此时我们要思考一个问题：为什么不能是对头结点进行插入操作，对尾结点进行删除操作呢？其实在刚开始我还真是这么想的，但是敲了一遍代码后(尤其是出队操作)发现，事情不是这么简单。原因就在于对链表的尾结点进行删除操作它的时间复杂度$(O(n)$​​，请参见**2.3.4**（像这种需要删除尾节点的，一般来说用一个指针指向尾节点就好了）

区分：链式队列的**队首指针指向队头节点，尾指针指向末尾的节点**

### 3.9.1 带头结点的链式队列

```c++
typedef struct LinkNode{
    ElemType data;
    struct LinkNode *next;
} LinkNode;

typedef struct {
    LinkNode *front, *rear;
} LinkQueue;

void InitQueue(LinkQueue &Q) {
    Q.front = Q.rear = (LinkNode *) malloc(sizeof (LinkNode));
    Q.front->next = NULL;
}

bool IsEmpty(LinkQueue Q) {
    if (Q.front == Q.rear) {
        return true;
    }
    return false;
}

bool EnQueue(LinkQueue &Q, ElemType x) { // 入队，头删尾插，rear指向链尾，front指向链头
    LinkNode *s = (LinkNode *) malloc(sizeof (LinkNode));
    if (s == NULL) {
        return false;
    }
    s->data = x;
    s->next = Q.rear->next;
    Q.rear->next = s;
    Q.rear = s;
    return true;
}

bool DeQueue(LinkQueue &Q, ElemType &x) {
    if (IsEmpty(Q)) {
        return false;
    }
    LinkNode *p = Q.front->next;
    x = p->data;
    Q.front->next = p->next;
    free(p);
    return true;
}
```

### 3.9.2 不带头结点的链式队列

```c++
typedef struct LinkNode{
    ElemType data;
    struct LinkNode *next;
} LinkNode;

typedef struct {
    LinkNode *front, *rear;
} LinkQueue;

void InitQueue(LinkQueue &Q) {
    Q.front = NULL;
    Q.rear = NULL;
}

bool IsEmpty(LinkQueue Q) {
    if (Q.front == NULL) {
        return true;
    }
    return false;
}

bool EnQueue(LinkQueue &Q, ElemType x) { // 入队
    LinkNode *s = (LinkNode *) malloc(sizeof (LinkNode));
    if (s == NULL) {         // 节点分配失败
        return false;
    }
    s->data = x;
    s->next = NULL;
    if (Q.front == NULL) { // 第一个结点入队
        Q.front = s;
        Q.rear = s;
    } else {
        Q.rear->next = s;
        Q.rear = s;
    }
    return true;
}

bool DeQueue(LinkQueue &Q, ElemType &x) {
    if (IsEmpty(Q)) {
        return false;
    }
    LinkNode *p = Q.front;
    x = p->data;
    Q.front = p->next;
    if (Q.rear == p) { // 最后一个结点出队
        Q.front = NULL;
        Q.rear = NULL;
    }
    free(p);
    return true;
}
```

## 3.10 双端队列

![image-20220420083032377](F:\learning\os_review\数据结构\assets\2616061-20230217095905849-1346422358.png)

双端队列的一个常见问题是：判断输出序列的合法性

对于双端队列来说，*只要栈能满足的序列则双端队列一定可以满足*，因此我们可以先用栈来初步确定输出序列是否合法。但是栈不满足的序列，在双端序列中则不一定。

队列运用：

1. 层次遍历，例如树的层次遍历和图的层次遍历
2. 操作系统中的先来先服务算法，缓冲区设计等

# 第四章 特殊矩阵的压缩存储

数组定义：由n个相同类型的数据元素构成的有限序列。

数组与线性表的关系：

1. 数组是线性表的推广，一维数组可以视作一个线性表，二维数组可以视作其元素为**定长数组的线性表**。
2. 数组一旦被定义，其维数和边界不会改变，只有存取元素和修改元素操作

## 4.1 一维数组的存储结构

![image-20220502101228604](F:\learning\os_review\数据结构\assets\2616061-20230217095905974-1045296884.png)

**位置关系：**$LOC[a_{i}]==LOC[a_{0}]+i*L$         L为元素的大小

## 4.2 二维数组的存储结构

![image-20220502101353951](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095904468-1955292533.png)

* 在$(M*N)$的二维数组中，若按照***行优先***存储，则`b[i][j]`的物理地址为：$(LOC + (i*N + j)*sizeof(ElemType)$
* 在$(M*N)$的二维数组中，若按照***列优先***存储，则`b[i][j]`的物理地址为：$(LOC + (j*M + i)*sizeof(ElemType))$

## 4.3 对称矩阵的压缩存储

**对称矩阵的定义**： 若n阶方阵中，任意一个元素$(a_{i,j})$有$(a_{i,j} = a_{j, i})$, 则称该矩阵为对称矩阵

![image-20220502102311029](F:\learning\os_review\数据结构\assets\2616061-20230217095906157-1473860418.png)

**存储策略：** (具体情况具体分析，下面的式子只是举一个例子)

1. 只存储主对角线和下三角区

   * 按照行优先原则，将各个元素存储到一维数组中

     * 一维数组长度设置为：$(\frac{(n+1)*n}{2})$，从0开始
     * $(a_{i,j})$是第几个元素：$(\frac{i*(i - 1)}{2} + j)$
     * 如果一维数组下标从0开始，则$(a_{i,j})$将存放在$(\frac{i*(i - 1)}{2} + j - 1)$的位置上

   * 按照*列优先*原则，将各个元素存储到一维数组中
     * $(a_{i,j})$是第几个元素：$([n + (n - 1) + .... + (n - j + 2)] + (i - j) + 1)$,自己画图推导

2. 只存储主对角线和上三角区

   * 按照行优先原则，将各个元素存储到一维数组中
   * 按照列优先原则，将各个元素存储到一维数组中

## 4.4 三角矩阵的压缩存储

![image-20220502105210624](F:\learning\os_review\数据结构\assets\2616061-20230217095906144-642148108.png)

**存储策略：**

* 按行优先原则存储下三角区

  * 一维数组长度设置为：$(\frac{(n+1)*n}{2} + 1)$，多出来的一个存储空间存放常量c
  * $(a_{i,j})$​是第几个元素： $k=\begin{cases}\frac{i(i - 1)}{2} + j - 1 & \text{i >= j}\\\\\frac{n(n+1)}{2} & \text{i < j}\end{cases}$

* 按行优先原则存储上三角区

  * 一维数组长度设置为：$(\frac{(n+1)*n}{2} + 1)$，多出来的一个存储空间存放常量c
  * $(a_{i,j})$​是第几个元素： $k=\begin{cases}\frac{(i - 1)(2n - i + 2)}{2} + (j - i) & \text{i <= j}\\\\\frac{n(n+1)}{2} & \text{i > j}\end{cases}\\$

## 4.5 三对角矩阵的压缩存储

![image-20220502111002973](F:\learning\os_review\数据结构\assets\2616061-20230217095904499-146221003.png)

**存储策略：**

按照行优先原则，$a_{i，j}$是第几个元素：

1. 前$i-1$行共有$3(i - 1) - 1$个元素
2. $a_{i,j}$是第$i$行的第$j - i + 2$个元素
3. 所以，$a\_{i,j}$是第$2i + j - 2$个元素
4. 因此：$k = 2i + j - 3$

![image-20220502111647565](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905848-1452437474.png)

## 4.6 稀疏矩阵的压缩存储

![image-20220502111903677](F:\learning\os_review\数据结构\assets\2616061-20230217095905942-1851653246.png)

存储时失去了随机存取的特性

![image-20220502112000581](F:\learning\os_review\数据结构\assets\2616061-20230217095904418-1691965330.png)

存储稀疏矩阵时，不仅要保存三元组表，还要保存稀疏矩阵的行数，列数和非零元素个数

## 4.7 小结

![image-20220502112046749](F:\learning\os_review\数据结构\assets\2616061-20230217095905885-986776958.png)

## 4.8 注意事项

1. 做题时可以采用特殊值法进行求解
2. 采用画图的方式来帮助理解存储过程
3. 注意压缩矩阵的下标一般从0开始

# 第五章 串

## 5.1 串的定义

**串：** 即字符串，是由零个或多个字符组成的有限序列。

**子串:** 串中任意个连续的字符组成的子序列

![image-20220502151332116](F:\learning\os_review\数据结构\assets\2616061-20230217095905983-903225347.png)

## 5.2 串的顺序存储

![image-20220502163555863](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095904393-48722995.png)

```c++
#define MAXLEN 255

// 静态数组实现（定长顺序存储）
typedef struct {
    char ch[MAXLEN];
    int length;
}SString;

/*
// 动态数组实现（堆分配存储） 需要手动free
typedef struct {
    char *ch;
    int length;
}HString;

HString S;
S.ch = (char *)malloc(MAXLEN * sizeof(char));
S.length = 0;
*/

void StrAssign(SString &S, char chars[], int charLen) {
    int i = 0;
    while (i < charLen) {
        S.ch[i + 1] = chars[i];
        i ++;
        S.length ++;
    }
}

bool SubString(SString &sub, SString S, int pos, int len) { // 求字串
    // 判断字串是否越界
    if (pos + len - 1 > S.length) {
        return false;
    }
    // 将S中的字串复制到sub中
    for (int i = pos; i < pos + len; ++i) {
        sub.ch[i - pos + 1] = S.ch[i];
    }
    sub.length = len;
    return true;
}

int StrCompare(SString S, SString T) { // 比较字符串大小
    for (int i = 1; i <= S.length && i <= T.length; ++i) {
        if (S.ch[i] != T.ch[i]) {
            return S.ch[i] - T.ch[i];
        }
    }
    // 如果扫描过的字符串都相同，则长度更长的字符串更大
    return S.length - T.length;
}

int Index(SString S, SString T) { // 获取T在S中第一次出现的位置
    int pos = 1, len = T.length;
    SString sub;
    while (pos <= S.length - T.length + 1) {
        SubString(sub, S, pos, len);
        if (StrCompare(sub, T) == 0) {
            return pos;
        }
        pos ++;
    }
    return 0;
}

void printString(SString S) {
    for (int i = 1; i <= S.length; ++i) {
        printf("%c", S.ch[i]);
    }
}
```

## 5.3 串的链式存储

![image-20220502164016242](F:\learning\os_review\数据结构\assets\2616061-20230217095905933-216035700.png)

## 5.4 串的朴素模式匹配算法

**算法思想：** 将主串中所有与模式串长度相同的子串找出来，依次与模式串进行匹配，如果有一个字符不匹配则立即放弃该子串，进行下一个子串的匹配。

**算法复杂度分析：**

1. 最坏时间复杂度：若模式串长度为m，主串长度为n，当每个子串的前$m - 1$个字符均匹配上，但是第$m$个字符不匹配时，则直到匹配成功/失败最多需要进行$(n - m + 1)*m$次比较，最坏时间复杂度为$O(nm)$
2. 最好时间复杂度：$(O(m)$
3. 比较好的情况：每个子串的第一个字符就与模式串不匹配

![image-20220503161326081](F:\learning\os_review\数据结构\assets\2616061-20230217095905809-1258207728.png)

**代码：**

```c++
int Index(SString S, SString T) { // S为主串，T为模式串
    int i = 1, j = 1;
    while(i <= S.length && j <= T.length) {
        if (S.ch[i] == T.ch[i]) {
            i ++;
            j ++;
        } else {
            i = i-(j-1)+1;   // 匹配失败，则移动到i的下一个位置
            j = 1;
        }
    }
    if (j > T.length) {
        return i-T.length;
    } else {
        return 0;
    }
}
```

## 5.5 KMP算法

### 5.5.1 概述

**算法简介：**KMP算法是一种高效的字符串模式匹配算法。它不像朴素模式匹配算法那样需要不断地回溯`i`，而是借助已经匹配成功的部分，保持`i`指针不回溯，通过修改指针`j`，让模式串尽量地移动到有效的位置。对于指针`j`的修改，首先需要针对特定的模式串生成对应的`next[]`数组，然后借助`next[]`数组来决定指针`j`的位置。

![img](F:\learning\os_review\数据结构\assets\2616061-20230217095904321-1022611989.png) ![img](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906069-87643544.png)

**时间复杂度：** $O(m+n)$

**next数组含义，是当第j个字符不匹配的时候，模式串应该回退到的位置，即next[j]**

### 5.5.2 手算next数组

`next[]`数组的**手算方法**：当第j个字符匹配失败，由前$j - 1$个字符组成的串记为S，则：$next[j]=S$的最长相等前后缀长度+1)。特别地：$next[1] = 0$

以下图为例：

![image-20220504142157529](F:\learning\os_review\数据结构\assets\2616061-20230217095905856-1267516132.png)

当第6个字符匹配失败时，前j-1个字符组成的串为：ABCAB

前缀$ A ,AB, ABC , ABCA$

后缀$B,AB,CAB,BCAB$

该串的最长相等前后缀为：AB，其长度为2

因此$(next[6] = 2+1=3)$

### 5.5.3 代码实现

计算机实现next数组的生成，代码看起来会比较懵，建议结合这篇文章进行学习：[（原创）详解KMP算法 - 孤\~影 - 博客园 (cnblogs.com)](https://www.cnblogs.com/yjiyjige/p/3263858.html)

```c++
void get_next(SString T, int next[]) {
    int i = 1, j = 0;
    next[1] = 0;
    while(i < T.length) {
        if (j == 0 || T.ch[i] == T.ch[j]) {
            i ++;
            j ++;
            next[i] = j;
        } else {
            j = next[j]; // 如果匹配失败，则模拟KMP的思想，对指针j进行回溯
        }
    }
}

int Index(SString S, SString T) {
    int i = 1, j = 1;
    int next[T.length + 1];
    get_next(T, next); // 求模式串的next数组
    while(i <= S.length && j <= T.length) {
        if (j == 0 || S.ch[i] == T.ch[j]) {
            i ++;
            j ++;
        } else {
            j = next[j]; // 移动模式串
        }
    }
    if (j > T.length) {
        return i - T.length; // 匹配成功
    } else {
        return 0; // 匹配失败
    }
}
```

### 5.5.4 KMP算法优化

![image-20220504145143282](F:\learning\os_review\数据结构\assets\2616061-20230217095904413-377607617.png)

**优化思想：** 如上图所示，主串中的字符$l$与模式串中的字符$g$不匹配，且next\[4]指向的字符与字符$g$相同，则next\[4]指向的字符也必定与字符$l$不匹配，此时我们直接让$next[4] = next[1]$即可 

即 s[j]==s[next[j]] ，这样就会进行无意义的匹配

```c++
void get_next(SString T, int next[]) {
    int i = 1, j = 0;
    next[1] = 0;
    while(i < T.length) {
        if (j == 0 || T.ch[i] == T.ch[j]) {
            i ++;
            j ++;
            /*
            1.如果此时模式串中p[i] != p[j]，则当进行kmp时，p[i]字符发生了不匹配，只需将j指针指向p[j]即可
            2.如果此时模式串中p[i] == p[j]，则当进行kmp时，p[i]字符发生了不匹配，那么调整之后j指向的				      p[j]也必然发生不匹配，此时需要继续调整j指针的指向。
            */
            if (p[i] == p[j]) {
                next[i] = next[j];
            } else {
                next[i] = j;
            }
        } else {
            j = next[j]; // 如果匹配失败，则模拟KMP的思想，对指针j进行回溯
        }
    }
}
```

以上代码可能不太好理解，我们可以借助next数组，间接生成nextval数组：

![image-20220504153323023](F:\learning\os_review\数据结构\assets\2616061-20230217095905857-2028240294.png)

## 5.6 注意事项

1. 注意这里的next[1]=0 表示模式串的第一个字符和主串中的第一个字符不匹配，故需要将主串的指针往后移动一位。模式串则回到j=1的位置
2. 一般来说，我们取序号通常从1开始，若为0开始，则相应的next应该减一
3. 注意考题的问法，例如移动距离和匹配次数

# 第六章 树与二叉树

## 6.1 树的基本概念

### 6.1.1 树的定义

**定义：** 树是n个结点的有限集，在任意一棵非空树中：

1. 有且仅有一个根节点
2. 当n>1时，其余结点可分为m个**互不相交**的有限集，其中每一个有限集本身也是一棵树，并且称为根的子树。

非空树的特性：

1. 有且仅有一个根节点
2. 没有后继结点的称为叶子结点
3. 有后继结点的称为分支结点
4. 除了根节点，任何一个结点有且仅有一个前驱结点
5. 每个结点可以有0个或多个后继结点

### 6.1.2 基本术语

**空树：** 结点数为0的树

**结点的层次（深度）：** 从上往下数

**节点的高度：** 从下往上数

**树的高度（深度）：** 总共多少层

⭐**结点的度：** 有几个分支

⭐**树的度：** 各结点的度的最大值

**有序树：** 树中结点的各子树从左到右是有次序的，不能互换

**无序树：** 树中结点的各子树从左到右是无次序的，可以互换

**森林：** 森林是由m(m>=0)棵互不相交的树组成的

## 6.2 树的性质

1. 结点数 = 总度数 + 1

   ![image-20220504191010466](F:\learning\os_review\数据结构\assets\2616061-20230217095905808-428821140.png)

2. 度为m的树第$i$层之多有$m^{i - 1}$个结点

3. 高度为h的m叉树至多有$\frac{m^h - 1}{m-1}$个结点，至少有h个结点

4. 高度为h，度为m的树至少有$h+m-1$个结点

6. 具有n个结点的m叉树的最小高度为$\lceil log_m(n(m-1) + 1) \rceil$

![image-20220504192733205](F:\learning\os_review\数据结构\assets\2616061-20230217095904353-1827983228.png)

## 6.3 二叉树

**定义：**二叉树是n个节点的有限集合

1. 或者为空二叉树，节点为0
2. 或者是以一个根节点和两个互不相交的被成为根的左子树和右子树构成，左子树和右子树分别又是一颗二叉树

**特点**

- 有左右子树之分，次序不能颠倒
- 与度为2的二叉树不同，度为2的树至少有三个节点，而二叉树可以为空

### 6.3.1 几种特殊的二叉树

**满二叉树：** 一棵高度为h，且含有$2^h - 1$个结点的二叉树

![image-20220505102750769](F:\learning\os_review\数据结构\assets\2616061-20230217095905912-1165656767.png)

**完全二叉树：** 当且仅当其每个结点都与高度为k的满二叉树中编号为1\~h的结点一一对应时，称为完全二叉树

![image-20220505104136968](F:\learning\os_review\数据结构\assets\2616061-20230217095906077-1370919221.png)

**二叉排序树：** **左子树上所有结点的关键字均小于根结点的关键字**；**右子树上所有结点的关键字均大于根结点的关键字**。左子树和右子树又各是一个二叉排序树。

![image-20220505105422075](F:\learning\os_review\数据结构\assets\2616061-20230217095904322-218130350.png)

**平衡二叉树：**又称“平衡二叉搜索树”，它首先是一棵二叉搜索树，**其次树上任意一个结点的左子树和右子树的深度之差不超过1。**平衡二叉树有更高的搜索效率。

![image-20220505110139937](F:\learning\os_review\数据结构\assets\2616061-20230217095906139-2108916613.png)

### 6.3.2 二叉树的性质

* ⭐设非空二叉树中度为0，1，2的结点的个数分别为$(n_0, n_1, n_2)$，则有：$(n_0 = n_2 + 1$) （即叶子结点比二分结点多1）

  * 推导：

    $设总结点数为n \\则有①：n = n_0 + n_1 + n_2 \\\ 由于：总结点数=总度数+1 \\\ 则有②：n = n_1 + 2n_2 + 1 \\ ②-①得：n_0 = n_2 + 1 $

* ⭐具有n个结点的*完全二叉树*的高度h为$\lceil log_2(n + 1) \rceil$      **也可以适用知道某一节点，求其高度**

  * 推导：

    $高度为h的完全二叉树的结点数最多为：\\\ 2^h - 1 \\\ 最少为： \\\ 2^{h-1} \\\ 因此，有如下式子：\\\ 2^{h-1} - 1< n \le 2^h - 1 \\\ \therefore 2^{h-1} < n + 1 \le 2^h \\\ \therefore h - 1 < log\_2(n+1) \le h \\\ \therefore h = \lceil log\_2(n + 1) \rceil $

* ⭐对于*完全二叉树*，可以由结点数n来推出度为0，1，2的结点的个数。

  * 若$n=2k$为偶数，则$(n_1 = 1, n_0 = k, n_2 = k - 1$

  * 若$n=2k - 1$为奇数，则$(n_1 = 0, n_0 = k, n_2 = k - 1)$

  * 推导：

    $首先，对于有n个结点的完全二叉树来说，其度为1的结点个数最多为1个 \\\ \therefore n_1 = 0 \ or\ 1 \\ 又因为n_0= n_2+ 1\\\ \therefore n_0 + n_2 = 2n_2 + 1=奇数\\ \therefore\ 当n = 奇数，n\_0=0;\\当n = 偶数，n_0=1; \\\ \therefore 根据n的奇偶，就可以求出n_0, n_1, n_2$
  
* ⭐对于*完全二叉树*，叶节点只能出现在最后两层。

* 其余性质见王道书p132页

### 6.4 解题技巧

1. 常用的二叉树性质 $n为偶数，则存在度为1的节点，n为奇数，则存在度为0的节点$
2. $n_0=n_2+1$​
3. 画出一般图形
4. 关于最大最小，取极端情况，最大则上一层取满，最小则每一层取最少
5. 深度，左孩子，右孩子，双亲的一些关系式

## 6.4 二叉树的存储结构

### 6.4.1 顺序存储

![image-20220505145642978](F:\learning\os_review\数据结构\assets\2616061-20230217095905856-658044656.png)\
![image-20220505145707551](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095904376-748420629.png)

```c++
#define MaxSize 100
struct TreeNode {
    ElemType value;
    bool isEmpty;
} TreeNode;

TreeNode t[MaxSize]; // 定义一个长度为MaxSize的数组t，按照从上到下，从左到右的顺序依次存储完全二叉树的各个结点

bool Init(TreeNode t[]) { // 初始化
    for (int i = 0; i < MaxSize; i ++) {
        t[i].isEmpty = true;
    }
}
```

对于一个顺序存储的*完全二叉树*来说

* 第i个结点的左孩子的位置为：2i

* 第i个结点的右孩子的位置为：2i + 1

* 第i个结点的父结点的位置为：$\lfloor \dfrac{i}{2} \rfloor$

* 第i个结点的父结点的层次为：$\lceil log_2(n + 1) \rceil$

* 若完全二叉树共有n个结点，则

  * 判断i是否有左孩子：$2i \le n$
  * 判断i是否有右孩子：$2i + 1 \le n$
  * 判断i是否为叶子/分支结点：$i> \lfloor \dfrac{n}{2} \rfloor$为叶子结点

**注意：顺序存储比较适合于满二叉树，完全二叉树，对于非完全二叉树来说，顺序存储会产生很多的空间浪费，因此对于一般二叉树来说，通常采用链式存储的方式。**

### 6.4.2 链式存储

```c++
/* 二叉链表 */
typedef struct BiTNode {
    ElemType data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;

BiTree root = NULL; // 定义一棵空树

// 插入根结点
root = (BiTree)malloc(sizeof(BiTNode));
root -> data = 0;
root -> lchild = NULL;
root -> rchild = NULL;

// 插入新结点
BiTNode *p = (BiTNode *)malloc(sizeof(BiTNode));
p -> data = 2;
p -> lchild = NULL;
p -> rchild = NULL;
root -> lchild = p;
```

对于二叉链表来说，如果要寻找一个结点的父结点，需要从根结点开始寻找。为了方便查找一个结点的根结点，我们可以采用三叉链表的方式：

```c++
typedef struct BiTNode{
    ElemType data;
    struct BiTNode *lchild, *rchild;
    struct BiTNode *parent;
} BiTNode, *BiTree;
```

关于**二叉链表的空指针域，有n+1个空指针**

## 6.5 二叉树的遍历

 关于遍历这里有一个很好的介绍

参考[二叉树的前中后和层序遍历详细图解（递归和非递归写法）_二叉树前序列为abcdefg的图-CSDN博客](https://blog.csdn.net/Monster_ii/article/details/82115772)

[二叉树三种遍历（动态图+代码深入理解）_二叉树的三种遍历例题带图-CSDN博客](https://blog.csdn.net/weixin_45525272/article/details/105837185)

### 6.5.1 先序遍历

**先序遍历：**根左右

```c++
typedef struct BiTNode {
    ElemType data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;

void PreOrder(BiTree T) {
    if (T == NULL) {
        return;
    }
    visit(T); // 访问根节点
    PreOrder(T -> lchild); // 遍历左子树
    PreOrder(T -> rchild); // 遍历右子树
}
```

```c++
// 非递归版本
void PreOrderTraversal(BinTree BT)
 {
    BinTree T = BT;
    Stack S = CreateStack(); // 创建并初始化堆栈S
    while (T || !IsEmpty(S))
    { // 当树不为空或堆栈不空
        while (T)
        {
            Push(S, T);            // 压栈，第一次遇到该结点
            printf("%d", T->Data); // 访问结点
            T = T->Left;           // 遍历左子树
        }
        if (!IsEmpty(S))
        {                 // 当堆栈不空
            T = Pop(S);   // 出栈，第二次遇到该结点
            T = T->Right; // 访问右结点
        }
    }
 }
```



### 6.5.2 中序遍历

**中序遍历：**左根右，常用于排序

```c++
void PreOrder(BiTree T) {
    if (T == NULL) {
        return;
    }
    PreOrder(T -> lchild); // 遍历左子树
    visit(T); // 访问根节点
    PreOrder(T -> rchild); // 遍历右子树
}
```

```c++
// 非递归版本
void InOrderTraversal(BinTree BT)
 {
    BinTree T = BT;
    Stack S = CreateStack(); // 创建并初始化堆栈S
    while (T || !IsEmpty(S))
    { // 当树不为空或堆栈不空
        while (T)
        {
            Push(S, T);  // 压栈
            T = T->Left; // 遍历左子树
        }
        if (!IsEmpty(S))
        {                          // 当堆栈不空
            T = Pop(S);            // 出栈
            printf("%d", T->Data); // 访问结点
            T = T->Right;          // 访问右结点
        }
    }
 }
```



### 6.5.3 后序遍历

**后序遍历：**左右根，常用于中缀转后缀，以及用于整颗二叉树删除。

```c++
void PreOrder(BiTree T) {
    if (T == NULL) {
        return;
    }
    PreOrder(T -> lchild); // 遍历左子树
    PreOrder(T -> rchild); // 遍历右子树
    visit(T); // 访问根节点
}
```

```c++
// 非递归版本
void PostOrderTraversal(BinTree BT)
 {
    BinTree T = BT;
    Stack S = CreateStack(); // 创建并初始化堆栈S
    vector<BinTree> v;       // 创建存储树结点的动态数组
    Push(S, T);
    while (!IsEmpty(S))
    { // 当树不为空或堆栈不空
        T = Pop(S);
        v.push_back(T); // 出栈元素进数组
        if (T->Left)
            Push(S, T->Left);
        if (T->Right)
            Push(S, T->Right);
    }
    reverse(v.begin(), v.end());       // 逆转
    for (int i = 0; i < v.size(); i++) // 输出数组元素
        printf("%d", v[i]->Data);
 }
```

三种遍历方法，都需要用到栈进行计算，最坏的空间复杂度为$O(n)$,二叉树的高度和节点数相同。

### 6.5.4 层序遍历

![image-20220508093635571](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905801-1031900689.png)

层序遍历，亦称*广度优先搜索*。它借助*队列*来实现了对二叉树每一层的遍历。

```c++
void BFS(BiTree T) {
    LinkQueue Q; // 队列相关内容见3.9.1
    InitQueue(Q);
    if (T == NULL) {
        return;
    }
    EnQueue(Q, T);
    while (!isEmpty(Q)) {
        BiTNode node;
        DeQueue(Q, node);
        visit(node);
        if (node -> lchild != NULL) {
            EnQueue(Q, node -> lchild);
        }
        if (node -> rchild != NULL) {
            EnQueue(Q, node -> rchild);
        }
    }
```

#### 6.5.4 推导结论

1. 先序遍历和后序遍历正好相反，则**二叉树高度等于其节点数**
2. 二叉树中序和后序相同，则每一颗子树没有左子树或者为空树。
3. 后序遍历时，若n是m的子孙，遍历时，n一定在m前。
4. 后序遍历可以找到m到n直接的路径（其中m是n的祖先）

## 6.6 由遍历序列构造二叉树

* 一个中序遍历序列可能对应多种二叉树形态
* 一个前序遍历序列可能对应多种二叉树形态
* 一个后序遍历序列可能对应多种二叉树形态
* 一个层序遍历序列可能对应多种二叉树形态

**因此：** 只给出一棵二叉树的前/中/后/层序遍历序列中的一种，不能唯一确定一颗二叉树，但是给出如下图所示的两种序列组和，可以唯一构造出一棵二叉树。

![image-20220508144312507](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905923-2072755599.png)

但是前序、后序、层序序列两两组合是无法唯一确定一棵二叉树的。

### 6.6.1 前序+中序遍历序列

前序遍历序列中，最左边的结点一定是根节点。因此，我们首先可以根据前序遍历序列先确定一个根节点，然后在中序遍历序列中，划分出左子树结点和右子树结点。然后，在根据前序遍历序列确定左子树的根节点，以此类推。

![image-20220508145214091](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095904420-895925152.png)

### 6.6.2 后续+中序遍历序列

这个过程大体跟6.6.1差不多，只不过，后序遍历序列最右边的结点是根节点。

![image-20220508145818716](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905885-1850753191.png)

### 6.6.3 层序+中序遍历序列

![image-20220508150526032](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906072-1775625362.png)

## 6.7 线索二叉树

### 6.7.1 概念

**中序线索二叉树的定义：** 一个二叉树通过如下的方法“穿起来”：所有原本为空的右(孩子)指针改为指向该节点在中序序列中的后继，所有原本为空的左(孩子)指针改为指向该节点的中序序列的前驱。

相应的，我们可以定义出后序线索二叉树和先序线索二叉树。

![image-20220509103916632](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095904457-706400708.png)

### 6.7.2 存储结构

```c++
typedef struct ThreadNode {
    ElemType data;
    struct ThreadNode *lchild, *rchild;
    int ltag, rtag; // 左右线索的标志。当tag=0时，child指针指向的是孩子；当tag=1时，child指向的是线索
}ThreadNode, *ThreadTree;
```

### 6.7.3 二叉树的线索化

**二叉树的线索化**以及通过**线索二叉树来寻找前驱后继**的问题，详细内容请参考：[线索二叉树的构造及前驱后继的查找 - Xiao·Tong - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiaotong-sun/p/16261584.html)

### 6.7.3.1中序线索二叉树

**中序线索二叉树的定义：** 一个二叉树通过如下的方法“穿起来”：所有原本为*空的右(孩子)指针*改为指向该节点在中序序列中的*后继*，所有原本为*空的左(孩子)指针*改为指向该节点的中序序列的*前驱*。

![image-20220509174728805](F:\learning\os_review\数据结构\assets\2616061-20230217100303116-320025609.png)

#### 1.1.1 朴素方法找中序前驱和后继

首先我们来思考如何用一种简单的方法来寻找中序遍历中某个结点的前驱和后继呢？

我们在遍历二叉树的时候，总是依次获取后继结点的，那么我们就不难想到，我们只要能够在遍历的过程中不断记录当前结点的前一个结点，那么就能够很方便的找到目标结点的前驱结点，为此只需额外设置一个pre指针来记录当前结点的前一个结点即可。下图给出了这个思想的示例：

![](F:\learning\os_review\数据结构\assets\2616061-20230217100303335-1270529048.jpg)

当指针q和目标结点p重合时，pre指针指向的结点即为目标结点的前驱结点。当然，利用这种方法我们也可以找到目标结点的后继结点，只需要让pre指针与p指针重合，此时q指针指向的就是后继结点（但是需要对最后一个结点的后继结点进行特殊处理）。

**代码：**

```c++
void findPre(BiTree T) {
    if (T == NULL) {
        return;
    }
    findPre(T -> lchild);
    visit(T);
    findPre(T -> rchild);
}

void visit(BiTNode *q) {
    if (q == p) {
        final = pre;
    } else {
        pre = q;
    }
}

BiTNode *p; // p指向目标结点
BiTNode *pre = NULL; // 指向当前结点的前驱结点
BiTNode *final = NULL; // 记录最终结果
```

#### 1.1.2 中序线索化

**中序线索化的基本思想：** 本质上就是借助1.1.1的思想，借助pre指针来记录前一个结点，若当前结点p的左孩子为空，则让其左指针指向pre使其成为前驱线索(需要借助`ltag=1`进行标记)，若pre指向的结点的右孩子为空，则让其右指针指向当前结点p使其成为后继线索(需要借助`rtag=1`进行标记)。

![](F:\learning\os_review\数据结构\assets\2616061-20230217100303274-1217968288.jpg)

**注意事项：**

* pre参数需要是**引用类型**，因为在程序运行中，pre的指向在不断进行更新。
* 处理中序遍历的最后一个结点时，可以不用判断rchild是否为NULL，因为中序遍历的最后一个结点的rchild必然为NULL否则就会继续遍历下去。但是，为了和其他线索二叉树统一起来，建议对最后一个结点进行一个非空判断。

**代码：**

```c++
typedef struct ThreadNode {
    ElemType data;
    struct ThreadNode *lchild, *rchild;
    int ltag, rtag;
} ThreadNode, *ThreadTree;

void InThread(ThreadTree p, ThreadTree &pre) {
    if (p == NULL) return;
    InThread(p->lchild, pre); // 递归线索化左子树
    if (p->lchild == NULL) { // 左子树为空，建立前驱线索
        p->lchild = pre;
        p->ltag = 1;
    }
    if (pre != NULL && pre->rchild == NULL) { // 建立前驱结点的后继线索
        pre->rchild = p;
        pre->rtag = 1;
    }
    pre = p;
    InThread(p->rchild, pre); // 递归线索化右子树
}

void CreatInThread(ThreadTree T) {
    ThreadNode *pre = NULL;
    if (T != NULL) {
        InThread(T, pre);
        if (pre->rchild == NULL) { // 处理最后一个结点
            pre->rtag = 1;
        }
    }
}
```

### 6.7.3.3 先序线索二叉树

**先序线索二叉树的定义：** 一个二叉树通过如下的方法“穿起来”：所有原本为*空的右(孩子)指针*改为指向该节点在先序序列中的*后继*，所有原本为*空的左(孩子)指针*改为指向该节点的先序序列的*前驱*。

![image-20220509195726029](F:\learning\os_review\数据结构\assets\2616061-20230217100303180-1477752862.png)

#### 1.2.1 先序线索化

先序线索化的基本思想与中序线索化的思想相同，在这里不做过多赘述。

![](F:\learning\os_review\数据结构\assets\2616061-20230217100303269-2086213054.jpg)

**注意事项：**

* 先序线索化过程中有一个需要格外注意的问题就是“转圈”问题，如下图所示的情况：当对d结点的左孩子线索化之后，由于先序遍历的规则，我们接下来应该遍历的是d的左子树也就是b，这样就导致了“转圈”问题。为了避免这个问题，我们就需要借助`ltag`判断左孩子是否为前驱线索。

* 处理先序遍历的最后一个结点时，其实也可以不用判断rchild是否为NULL，因为先序遍历的最后一个结点的rchild必然为NULL否则就会继续遍历下去。

  ![image-20220509202135408](F:\learning\os_review\数据结构\assets\2616061-20230217100303179-1787184534.png)

**代码：**

```c++
typedef struct ThreadNode {
    ElemType data;
    struct ThreadNode *lchild, *rchild;
    int ltag, rtag;
} ThreadNode, *ThreadTree;

void PreThread(ThreadTree p, ThreadTree &pre) {
    if (p == NULL) return;
    if (p->lchild == NULL) { // 左子树为空，建立前驱线索
        p->lchild = pre;
        p->ltag = 1;
    }
    if (pre != NULL && pre->rchild == NULL) { // 建立前驱结点的后继线索
        pre->rchild = p;
        pre->rtag = 1;
    }
    pre = p;
    if (p -> ltag == 0) { // 避免转圈问题
        PreThread(p->lchild, pre); // 递归线索化左子树
    }
    PreThread(p->rchild, pre); // 递归线索化右子树
}

void CreatPreThread(ThreadTree T) {
    ThreadNode *pre = NULL;
    if (T != NULL) {
        PreThread(T, pre);
        if (pre->rchild == NULL) { // 处理最后一个结点
            pre->rtag = 1;
        }
    }
}
```

### 6.7.3.4 后序线索二叉树

**后序线索二叉树的定义：** 一个二叉树通过如下的方法“穿起来”：所有原本为*空的右(孩子)指针*改为指向该节点在后序序列中的*后继*，所有原本为*空的左(孩子)指针*改为指向该节点的后序序列的*前驱*。

![image-20220509195922943](F:\learning\os_review\数据结构\assets\2616061-20230217100303247-786792675.png)

#### 1.3.1 后序线索化

后序线索化的基本思想与中序线索化的思想相同，在这里不做过多赘述。

![](F:\learning\os_review\数据结构\assets\2616061-20230217100303294-964934933.jpg)

**注意事项：**

* 后序线索化过程中不会出现“转圈”问题
* 但是，处理后序遍历的最后一个结点时，需要进行额外的判断，确定最后一个结点的右孩子是否为空。

**代码：**

```c++
typedef struct ThreadNode {
    ElemType data;
    struct ThreadNode *lchild, *rchild;
    int ltag, rtag;
} ThreadNode, *ThreadTree;

void PostThread(ThreadTree p, ThreadTree &pre) {
    if (p == NULL) return;
    PostThread(p->lchild, pre); // 递归线索化左子树
    PostThread(p->rchild, pre); // 递归线索化右子树
    if (p->lchild == NULL) { // 左子树为空，建立前驱线索
        p->lchild = pre;
        p->ltag = 1;
    }
    if (pre != NULL && pre->rchild == NULL) { // 建立前驱结点的后继线索
        pre->rchild = p;
        pre->rtag = 1;
    }
    pre = p;
}

void CreatPreThread(ThreadTree T) {
    ThreadNode *pre = NULL;
    if (T != NULL) {
        PostThread(T, pre);
        if (pre->rchild == NULL) { // 处理最后一个结点
            pre->rtag = 1;
        }
    }
}
```

### 6.7.3.5 线索二叉树找前驱/后继

#### 1.1 中序线索二叉树找后继

在中序线索二叉树中找到指定结点p的中序后继next

1. 若`p->rtag==1`，则`next=p->rchild`

2. 若`p->rtag==0`，则说明p一定有右孩子，此时`next=p的右子树中最左下结点`

   ![image-20220512094730279](F:\learning\os_review\数据结构\assets\2616061-20230217100303275-1637218424.png)

**代码：**

```c++
ThreadNode *Firstnode(ThreadNode *p) { // 找最左下结点
    while (p -> ltag == 0) {
        p = p -> lchild;
    }
    return p;
}

ThreadNode *Nextnode(ThreadNode *p) { // 判断p是否有右子树
    if (p -> rtag == 0) {
        return Firstnode(p -> rchild);
    } else {
        return p -> rchild;
    }
}

void InOrder(ThreadNode *T) { // 利用线索二叉树实现非递归的中序遍历
    for (ThreadNode *p = Firstnode(T); p != NULL; p = Nextnode(p)) {
        visit(p);
    }
}
```

#### 1.2 中序线索二叉树找前驱

在中序线索二叉树中找到指定结点p的中序前驱pre

1. 若`p->ltag==1`，则`pre=p->lchild`

2. 若`p->ltag==0`，则说明p一定有左孩子，此时`pre=p的左子树中最右下结点`

   ![image-20220512095201562](F:\learning\os_review\数据结构\assets\2616061-20230217100303124-1485189598.png)

**代码：**

```c++
ThreadNode *Lastnode(ThreadNode *p) { // 找最左下结点
    while (p -> rtag == 0) {
        p = p -> rchild;
    }
    return p;
}

ThreadNode *Prenode(ThreadNode *p) { // 判断p是否有右子树
    if (p -> ltag == 0) {
        return Lastnode(p -> lchild);
    } else {
        return p -> lchild;
    }
}

void RevInOrder(ThreadNode *T) { // 利用线索二叉树实现非递归的逆向中序遍历
    for (ThreadNode *p = Lastnode(T); p != NULL; p = Prenode(p)) {
        visit(p);
    }
}
```

#### 2.1 先序线索二叉树找后继

在先序线索二叉树中找到指定结点p的先序后继next

1. 若`p->rtag==1`，则`next=p->rchild`

2. 若`p->rtag==0`，则说明p一定有右孩子，此时又分为两种情况：

   1. 若p有左孩子，则`next=p->lchild`
   2. 若p没有左孩子，则`next=p->rchild`

   ![image-20220512100443404](F:\learning\os_review\数据结构\assets\2616061-20230217100303183-553408752.png)

**代码：**

```c++
ThreadNode *Nextnode(ThreadNode *p) {
    if (p -> rtag == 1) {
        return p -> rchild;
    } else if (p -> rtag == 0 && p -> ltag == 0) {
        return p -> lchild;
    } else if (p -> rtag == 0 && p -> ltag == 1) {
        return p -> rchild;
    }
}
```

#### 2.2 先序线索二叉树找前驱

在先序线索二叉树中找到指定结点p的先序前驱pre

1. 若`p->ltag==1`，则`pre=p->lchild`

2. 若`p->ltag==0`，由于先序遍历的特性，p的左右子树不可能为其先序前驱，且先序前驱只可能存在于上层结点中。因此普通的二叉链表除非从头遍历否则是无法找到其先序前驱的，我们需要借助三叉链表才能实现。

   ![image-20220512101754989](F:\learning\os_review\数据结构\assets\2616061-20230217100303202-657097421.png)\
   **对情况3的额外说明**\
   ![image-20220512102021866](F:\learning\os_review\数据结构\assets\2616061-20230217100303232-726368432.png)

#### 2.3 后序线索二叉树找后继

在后序线索二叉树中找到指定结点p的后序后继next

1. 若`p->rtag==1`，则`next=p->rchild`

2. 若`p->rtag==0`，由于后序遍历的特性，p的左右子树不可能为其后序后继，且后序后后继只可能存在于上层结点中。因此普通的二叉链表除非从头遍历否则是无法找到其后序后继的，我们需要借助三叉链表才能实现。

   ![image-20220512103336642](F:\learning\os_review\数据结构\assets\2616061-20230217100303220-1610686924.png)\
   **对情况3的额外说明**\
   ![image-20220512103718289](F:\learning\os_review\数据结构\assets\2616061-20230217100303135-1123578989.png)



#### 2.4 后序线索二叉树找前驱

在后序线索二叉树中找到指定结点p的后序前驱pre

1. 若`p->ltag==1`，则`pre=p->lchild`

2. 若`p->ltag==0`，则说明p一定有左孩子，此时又分为两种情况：

   1. 若p有右孩子，则`next=p->rchild`
   2. 若p没有右孩子，则`next=p->lchild`

   ![image-20220512102923688](F:\learning\os_review\数据结构\assets\2616061-20230217100303144-1069737864.png)

### 6.7.3.6. 小结

|                        | 中序线索化   | 先序线索化   | 后序线索化 |
| ---------------------- | ------------ | ------------ | ---------- |
| **转圈问题**           | 无           | 有           | 无         |
| **最后一个结点的后继** | 直接赋值null | 直接赋值null | 需要判断   |

***

|            | 中序线索二叉树 | 先序线索二叉树 | 后序线索二叉树 |
| ---------- | -------------- | -------------- | -------------- |
| **找前驱** | √              | ×              | √              |
| **找后继** | √              | √              | ×              |

## 6.8 树的存储结构

### 6.8.1 双亲表示法(顺序存储)

![image-20220512171948556](F:\learning\os_review\数据结构\assets\2616061-20230217095906066-1028709556.png)

* 插入结点时只需要在数组的空闲处添加数据元素data并且正确写入parent的位置即可。

* 删除结点时，我们首先需要判断该结点是否有孩子，如果没有孩子结点，则直接删除即可；如果有孩子结点，我们还需要查找该结点的所有孩子以及孩子的孩子，然后一并删除。

  **在删除时，我们也有两种选择：**

  * 删除之后，该数组元素保持空缺
  * 删除之后，将最后一个数组元素移动到该位置

**优缺点：**

* 优点：查指定结点的双亲很方便
* 缺点：查指定结点的孩子只能从头遍历

### 6.8.2 孩子表示法(顺序+链式存储)

![image-20220512173621563](F:\learning\os_review\数据结构\assets\2616061-20230217095906026-1681984460.png)

* 优点：找孩子方便
* 缺点：找父节点不方便

### 6.8.3 孩子兄弟表示法(链式存储)

![image-20220512174322239](F:\learning\os_review\数据结构\assets\2616061-20230217095904377-1291579274.png)

通过孩子兄弟表示法，我们可以实现*树和二叉树之间的转化*

![image-20250311102756647](F:\learning\os_review\数据结构\assets\image-20250311102756647.png)

### 6.8.4 森林和二叉树的转换

![image-20220512174520885](F:\learning\os_review\数据结构\assets\2616061-20230217095905934-111888801.png)

![image-20250311103101943](F:\learning\os_review\数据结构\assets\image-20250311103101943.png)

## 6.9 树、森林的遍历

### 6.9.1 树的先根遍历

![image-20220512175702571](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905937-2071443344.png)

### 6.9.2 树的后根遍历

![image-20220512180135525](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095904375-2056289434.png)

### 6.9.3 树的层次遍历

![image-20220513092211752](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905891-1295573196.png)

### 6.9.4 森林的先序遍历

森林的先序遍历的效果等同于*依次对各个树进行先根遍历*。

此外，我们也可以采用孩子兄弟表示法将森林转化为一棵二叉树，然后对二叉树进行*先序遍历*。

![image-20220513092824514](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906154-865510595.png) ![image-20220513092840932](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095904324-1704650247.png)

### 6.9.5 森林的中序遍历

森林的中序遍历的效果等同于*依次对各个树进行后根遍历*。

我们也可以将森林转化成二叉树，然后对二叉树进行*中序遍历*。

### 6.9.6 小结

| 树    | 森林   | 二叉树  |
| ---- | ---- | ---- |
| 先根遍历 | 先序遍历 | 先序遍历 |
| 后根遍历 | 中序遍历 | 中序遍历 |

1. 若森林（或者树）转化为二叉树后，有部分节点无左孩子，说明这些节点在原森林（树）中为叶节点
2. 注意转化时的结论，二叉树的某一个节点，若有右孩子，则右孩子为他的兄弟。
3. 如果树和森林不好遍历，可转化为二叉树进行遍历
4. 特殊值法在这部分的选择题中很好用，例如回到王道书p176 16题 8题

## 6.10 二叉排序树

### 6.10.1 查找

![image-20220513100701643](F:\learning\os_review\数据结构\assets\2616061-20230217095905897-1152510115.png)

```c++
typedef struct BSTNode {
    ElemTpye key;
    struct BSTNode *lchild, *rchild;
}BSTNode, *BSTree;

// 非递归版本
BSTNode *BST_Search(BSTree T, ElemType key) {
    while (T != NULL && T -> key != key) {
        if (key < T -> key) {
            T = T -> lchild;
        } else {
            T = T -> rchild;
        }
    }
    return T;
}

// 递归版本  时间复杂度O(h),空间复杂度O(h)，递归调用栈
BSTNode *BST_Search(BSTree T,ElemType key)
{
    if(T==NULL)  // 子树为空
        return NULL;
    else if(T->key==key)
     return T;
    else if(T->key>key) //当前节点大于key
        return BST_Search(T->left,key);
    else
        return BST_Search(T->right,key);
}

```

**查找效率分析：**

查找长度：在查找运算中，需要对比关键字的次数称为查找长度。

![image-20220513203327931](F:\learning\os_review\数据结构\assets\2616061-20230217095906137-619634081.png) ![image-20220513203359720](F:\learning\os_review\数据结构\assets\2616061-20230217095904394-238941974.png)

### 6.10.2 插入

* 若原二叉排序树为空，则直接插入结点；
* 否则，若关键字小于根节点值，则插入到左子树，若关键字大于根节点值，则插入到右子树。

```c++
// 递归版本
int BST_Insert(BSTree &T, ElemType key) {
    if (T == NULL) {
        T = (BSTNode *) malloc(sizeof(BSTNode));
        T -> key = key;
        T -> lchild = NULL;
        T -> rchild = NULL;
        return 1;
    } else {
        if (key == T -> key) {
            return 0;
        } else if (key < T -> key) {
            return BST_Insert(T -> lchild, key);
        } else if (key > T -> key) {
            return BST_Insert(T -> rchild, key);
        }
    }
}
// 非递归版本
int BST_Insert(BSTree &T,ElemType key)
{
    int flag=0; // 表示是否插入成功
    BSTNode *temp=new BSTNode();
    temp->key=key;
    BSTNode *pre=NULL;
    while(T!=NULL)
    {
 
       if(T->key>key)
       {
           pre=T;
        T=T->left;
       }
        else if(T->key<key)
        {
            pre=T;
            T->right;
        }
        else
        return flag;
        
    }
    if(pre->key>key)
        pre->left=temp;
    else
        pre->right=temp;
    return flag+1;
    
}
```

### 6.10.3 构造

```c++
void CreatBST(BSTree &T, ElemType data[], int n) {
    T = NULL; // 初始时T为空树
    for (int i = 0; i < n; i ++) {
        BST_Insert(T, data[i]); // 将每个元素插入到二叉排序树中
    }
}
```

**注意：** 不同的关键字序列可能得到同款二叉排序树，也可能得到不同款二叉排序树

### 6.10.4 删除

1. 若被删除结点z是叶子结点，则直接删除即可。

2. 若结点z只有一棵左子树或右子树，则让z的子树成为z的父节点的子树，代替z的位置。

3. 若**结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱）**，这样就转换成了第一或第二种情况。（这里是中序遍历的前驱和后继）。

   ![image-20220513202722117](F:\learning\os_review\数据结构\assets\2616061-20230217095905914-929435026.png)或 ![image-20220513202737003](F:\learning\os_review\数据结构\assets\2616061-20230217095905998-1661839056.png)

## 6.11 平衡二叉树(AVL)

![image-20220514104005366](F:\learning\os_review\数据结构\assets\2616061-20230217095904376-1708686955.png)

### 6.11.1 LL

![image-20220514104058745](F:\learning\os_review\数据结构\assets\2616061-20230217095905847-519817615.png)


![image-20220514104524832](F:\learning\os_review\数据结构\assets\2616061-20230217095906130-785848301.png)

### 6.11.2 RR

![image-20220514104322238](F:\learning\os_review\数据结构\assets\2616061-20230217095904346-324573624.png)\
\
![image-20220514104612312](F:\learning\os_review\数据结构\assets\2616061-20230217095905973-743753584.png)

### 6.11.3 LR

![image-20220514105519427](F:\learning\os_review\数据结构\assets\2616061-20230217095905961-1282956650.png)\
\
![image-20220514105732187](F:\learning\os_review\数据结构\assets\2616061-20230217095904327-730816398.png)

### 6.11.4 RL

![image-20220514105859564](F:\learning\os_review\数据结构\assets\2616061-20230217095905914-1331972161.png)\
\
![image-20220514105545052](F:\learning\os_review\数据结构\assets\2616061-20230217095905941-1159149630.png)

### 6.11.5 删除：

同上面的  **LL,RR,LR,RL**,**删除策略也和二叉排序树的删除方式一样，删除后再进行左旋或者右旋**。

### 6.11.6 查找效率分析

![image-20220514111246677](F:\learning\os_review\数据结构\assets\2616061-20230217095904370-220852171.png)

注意这个结论，有以下几个推论：

1. $n_0=0,n_1=1,n_2=2,n_3=4,n_4=7,n_5=12$ 这些常用的节点可以帮助快速求解一些结点。
2. 每个非叶结点的平衡因子为1，说明为最小平衡二叉树。

## 6.12 哈夫曼树

### 6.12.1 基本概念

**结点的带权路径长度：** 从树的根结点到当前结点所经过的路径长度(边数)与该结点权值的乘积

**树的带权路径长度：** 树中所有叶子结点的带权路径长度之和(WPL, Weighted Path Length)

**哈夫曼树：** 带权路径长度最小的二叉树，也称最优二叉树

**前缀编码：** 没有一个编码是另一个编码的前缀

**哈夫曼编码：** 字符集中每一个字符作为叶子结点，各个字符出现的频度视为结点的权值，构造出哈夫曼树。让哈夫曼树的左分支为0，右分支为1，则可以构造出哈夫曼编码。

**性质：**

1. 哈夫曼树节点数为$2n-1$ ,n为叶子节点数
2. 哈夫曼树中不存在度为1的节点
3. 哈夫曼编码是严格的前缀编码
4. 权值计算可以通过常规方法，也可以通过求非叶节点之和来求出带权路径长度

**推广：**

k叉树的哈夫曼树结点有$n=\dfrac{n_0-1}{k-1}+n_0$，其中$n_0$为叶节点个数

如果k叉树中$\dfrac{n_0-1}{k-1}$无法整除，则需要增加$n_0$个数（增加“0”节点）

### 6.12.2 哈夫曼树的构造

![image-20220514101130121](F:\learning\os_review\数据结构\assets\2616061-20230217095905968-2019654703.png)

### 6.12.3 并查集

**1.定义：**并查集是一种简单的集合（附带一系列集合操作），同时每个集合交集为空

**2.部分操作**

```c++
Initial(S):  // 将集合S的每个元素都初始化为一个单元素集合S
Union(S,Root1,Root2):  // 把两个没有交集的集合合并为一个集合
Find(S,x):   // 查找集合S中单元素x所在的子集合
```

**3.实现：**

通常通过树的双亲表示法进行实现（存储结构为顺序表（data和parent），数组下标代表元素名，其元素的s[i]表示双亲域。根节点的双亲域为负数（负数的绝对值表示该集合有多少元素）

```c++
#define SIZE 100
int UFSets[SIZE];

// 初始化操作
void Initial(int S[])
{
	for (int i = 0; i < SIZE; i++)
		S[i] = -1;
}

// 查找
int Find(int S[], int x)
{
	while (S[x] >= 0) //循环寻找 x 的根
		x = S[x];
	return x; //根的 S[] 小于0
}

// Union
void Union(int S[], int Root1, int Root2)
{
	//要求Root1与Root2是不同的，且表示子集合的名字
	if (Root1 == Root2) return;
	S[Root2] = Root1;
}
```

四、并查集的优化
**（一）Union操作优化（小树并入大树）**
**问题：若只有一个子集合，且这一个子集合是一条细长的链，若结点数是 n ,那么查找的最坏时间复杂度是O(n)**
**优化思路：在每次Union操作构建树的时候，尽可能让树不长高**
方法：

1. 每个根结点不再用-1表示，用根结点的绝对值表示树的结点总数，例如，原先数组值如图

   ![img](F:\learning\os_review\数据结构\assets\8a3aca4230ff2fe62a50ff254c6362ec.png)

图中表示结点 1 、13 、14是根结点。
优化后为

![img](F:\learning\os_review\数据结构\assets\62b88b26dd4e05ce0f1d0f7764629ee7.png)

图中仍然表示结点 1、13、14为根结点，同时说明了根结点1子集合下共有4个元素，其他同理。

优化后的Union

```c++
void Union(int S[], int Root1, int Root2)
{
	//要求Root1与Root2是不同的，且表示子集合的名字
	if (Root1 == Root2) return;
	if (S[Root2] > S[Root1]) //Root2结点数更少
	{
		S[Root1] += S[Root2];
		S[Root2] = Root1; //小树合并到大树，即Root2指向Root1
	}
	else
	{
		S[Root2] += S[Root1];
		S[Root1] = Root2;
	}
}
```

**构造后的集合高度不超过$\lceil{log_2{(n+1)}}\rceil$​**

#### （二）Find操作优化（压缩路径）

- 问题：反复查找某个结点的根结点，每次都会花费大量时间
- 优化思路：只要查找一次，就将查找路径上的所有结点都挂到根结点下面，如图,查找L的根结点A，查找一次过后，就将E、B、L全部挂到根结点A之下

![img](F:\learning\os_review\数据结构\assets\b20ccb77cbf0560f17b1bbb4c57ada10.png)

```c++
int Find(int S[], int x)
{
	int root = x;
	while (S[root] >= 0) root = S[root]; //循环找到根
	while (x != root) //x不为根结点，则压缩路径
	{
		int t = S[x]; //t指向x的父节点
		S[x] = root; //x直接挂到根结点下
		x = t;
	}
	return root; //返回根节点编号
}
```

优化后，并查集的查找时间不超过$O(\alpha(n))$ 其中$\alpha(n)<4$

# 第七章 图

## 7.1 图的基本概念

**图的定义：**

![image-20220516173438612](F:\learning\os_review\数据结构\assets\2616061-20230217095905854-1208194295.png)

**有向图、无向图：**

![image-20220516173855276](F:\learning\os_review\数据结构\assets\2616061-20230217095904445-753516875.png)

**简单图：** 1.不存在重复的边 2.不存在顶点到自身的边

**顶点的度、入度、出度：**

![image-20220516174443580](F:\learning\os_review\数据结构\assets\2616061-20230217095906043-265777102.png)

**顶点-顶点的关系描述：**

![image-20220516174747195](F:\learning\os_review\数据结构\assets\2616061-20230217095906103-31053738.png)

**连通图、强连通图：**

![image-20220516175115054](F:\learning\os_review\数据结构\assets\2616061-20230217095904435-1289481062.png)

区分连通图和强连通图：连通图是针对无向图来说的，强连通图是针对有向图来说的。

**子图、生成子图：**

![image-20220516175346852](F:\learning\os_review\数据结构\assets\2616061-20230217095906168-348798434.png)

**连通分量：** 无向图中的***极大连通子图***称为连通分量。

**极大连通子图：** 子图必须是连通的，并且包含尽可能多的顶点和边

**强连通分量：** 有向图中的***极大强连通子图***称为强连通分量

**极大强连通子图：** 子图必须是强连通的，并且包含尽可能多的边

**生成树：**

![image-20220516180136931](F:\learning\os_review\数据结构\assets\2616061-20230217095906105-1543891565.png)

**边的权、带权图：**

![image-20220516180521525](F:\learning\os_review\数据结构\assets\2616061-20230217095904427-607411873.png)

**完全图：**

![image-20220516180610180](F:\learning\os_review\数据结构\assets\2616061-20230217095906002-884000329.png)

## 7.2 邻接矩阵

![image-20220516181344230](F:\learning\os_review\数据结构\assets\2616061-20230217095906067-1964942506.png)

邻接矩阵的性质：

1. 无向图的邻接矩阵一定是对称矩阵
2. 稠密图适合用邻接矩阵的方式存储
3. 容易确定图中任意两个顶点之间是否有顶点相连
4. 空间复杂度为$O(N^2)$
5. 一个图的邻接矩阵是唯一的

![image-20220516183115844](F:\learning\os_review\数据结构\assets\2616061-20230217095904424-775353052.png) ![image-20220516183332221](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906064-272560385.png)

```c
#define MaxVertexNum 100	//顶点数目的最大值
typedef char VertexType;	//顶点的数据类型
typedef int EdgeType;	//带权图中边上权值的数据类型
typedef struct{
	VertexType Vex[MaxVertexNum];	//顶点表
	EdgeType Edge[MaxVertexNum][MaxVertexNum];	//邻接矩阵，边表
	int vexnum, arcnum;	//图的当前顶点数和弧树
}MGraph;
```

解释一下：

$(A^2[1][4])$ 可以理解为第一个矩阵的第1行×第二个矩阵的第4列。

## 7.3 邻接表

![image-20220517092302067](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906080-656628686.png)

```c++
typedef struct TableNode {
    int data; // 边指向哪个结点
    struct TableNode *next; // 指向下一条边的指针
}TableNode;

typedef struct TableElement {
    Elemtype v; // 顶点信息
    TableNode *first; // 指向第一条边
}TableElement, TElement[Maxsize];

typedef struct Table {
    TElement table;
    int v, e; // 记录边数和顶点数
}
```

![image-20220517092405049](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095904377-1563775307.png)

## 7.4 十字链表、邻接多重表

![image-20220518110549544](F:\learning\os_review\数据结构\assets\2616061-20230217095906159-1890952109.png)

![image-20220518112029741](F:\learning\os_review\数据结构\assets\2616061-20230217095906069-238572956.png)

![image-20220518112604834](F:\learning\os_review\数据结构\assets\2616061-20230217095904379-1825876822.png)

## 7.5 图的广度优先搜索

![image-20220518164725135](F:\learning\os_review\数据结构\assets\2616061-20230217095906077-953064181.png)

* 同一个图的邻接矩阵表示方式唯一，因此广度优先遍历序列唯一
* 同一个图的邻接表表示方式不唯一，因此广度优先遍历序列不唯一

对于上面的代码实现，存在一个bug，就是当该图为非连通图时，无法遍历完所有结点。

![image-20220518165644127](F:\learning\os_review\数据结构\assets\2616061-20230217095905986-533337259.png) ![image-20220518170123273](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095904455-1014841961.png)

**广度优先生成树：** 在广度优先遍历时，我们会沿着一定的路径进行结点的遍历，在这个过程中我们会确定出$(n-1)$条路径，这些路径就会构成一个广度优先生成树。但是采用邻接表存储的图，它的广度优先生成树取决于邻接表(因此不唯一)

![image-20220518170912422](F:\learning\os_review\数据结构\assets\2616061-20230217095906045-1474120860.png)\
\
![image-20220518170936493](F:\learning\os_review\数据结构\assets\2616061-20230217095906158-1428013542.png)

![img](F:\learning\os_review\数据结构\assets\34ef3a4cc726cad76770f7d9235fb08b.png)

## 7.6 图的深度优先遍历

![image-20220518172446455](F:\learning\os_review\数据结构\assets\2616061-20230217095904425-1284692918.png)

![img](F:\learning\os_review\数据结构\assets\ea6af9544af6d10a2764635ffaa97ee4.png)

## 7.7 最小生成树

**最小生成树：** 对于一个*带权连通无向图*来说，可能有多个生成树，每个生成树的权值(边权之和)也可能不同。其中，*权值最小*的生成树称为最小生成树。

由带权连通无向图获取最小生成树的算法主要有两种：Prim算法、Kruskal算法

### 7.7.1 Prim算法

**简介：** Prim算法的整体思想是围绕着图的顶点进行的。它从某一顶点开始构建生成树，每次将代价最小的顶点纳入生成树，直到顶点全部纳入为止。

**时间复杂度：** $(O(|V|^2)$ 适用于边稠密图

![](F:\learning\os_review\数据结构\assets\2616061-20230217095906108-334328478.jpg)

### 7.7.2 Kruskal算法

**简介：** Kruskal算法的整体思想是围绕着图的边进行的。它每次选择一条权值最小的边，使这个边两端的顶点相连接（如果这条边两端的顶点已经被连通，那么就不选），直到所有顶点都连通。

**时间复杂度：** $O(|E|log\_2|E|$ 适用于边稀疏图

![](F:\learning\os_review\数据结构\assets\2616061-20230217095905907-960866106.jpg)

## 7.8 最短路径问题

![image-20220519153518923](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095904373-1320113170.png)

### 7.8.1 BFS算法

BFS算法可以用来获取*无权图*的单源最短路径。它的基本思想就是从某一点出发，广度优先搜索无权图，在这个过程中，广度优先搜索的第一层到源点的路径长度为1，之后几层依次加1。

![image-20220519154729751](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905802-594714947.png)

其中，`d[]`记录了从源点到该点的最短路径，路径的形式可以由`path[]`推导出来。

### 7.8.2 Dijkstra算法

Dijkstra算法可以用来获取*带权(非负)图*的单源最短路径。算法过程如下：

![image-20220519173714328](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905935-892868632.png)

![](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095904487-52181550.jpg) ![20225191732](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906221-1198521193.jpg) ![20225191733](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906134-57154582.jpg)

**特别强调：**

Dijkstra算法不适用于有*负权值*的带权图

![image-20220519174309805](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095904372-113075760.png)

### 7.8.3 Floyd算法

Floyd算法是用来求解*每一对顶点之间的最短路径*问题。

使用*动态规划*的思想 **时间复杂度：\\(O(|V|^3)\\)**,**空间复杂度：\\(O(|V|^2)\\)**

![image-20220520151916175](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905808-1273351936.png)

**特别强调：** Floyd算法可以解决带负权值的图，但是不能解决带有“负权回路”的图。

![image-20220520153307321](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906031-1205144987.png)

### 7.8.4 小结

![image-20220520153403865](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906956-1861414800.png)

## 7.9 有向无环图

**有向无环图：** 若一个有向图中不存在环路，则称为有向无环图，简称DAG图

![image-20220521122848217](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095904787-1477491215.png)

![image-20220521122933881](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095905797-1651850606.png)

## 7.10 拓扑排序

![image-20220521134026645](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906078-1084050685.png)

**拓扑排序：** 就是将DAG图中的*活动*按先后顺序进行排序。

拓扑排序的一个基本实现思路：

1. 从AOV网中选择一个没有前驱(入度为0)的顶点并输出。
2. 从AOV网中删除该顶点以及与之相连的有向边。
3. 重复1、2直到AOV网为*空*或*当前网中不存在入度为0的顶点为止*

**性质：** 拓扑排序和逆拓扑排序序列可能不唯一。若图中有环，则不存在(逆)拓扑排序序列

**代码实现：** 时间复杂度(邻接表)：$(O(|V| + |E|)$（邻接矩阵）：$(O(|V|^2))$

![image-20220521135621558](F:\learning\os_review\数据结构\assets\2616061-20230217095907089-1908341703.png) ![image-20220521135657012](F:\learning\os_review\数据结构\assets\2616061-20230217095907309-1993032999.png)

**拓扑排序的DFS实现**

```python
 visited = set()
    stack = []
    temp_mark = set()  # 用于检测环

    def dfs(node):
        if node in temp_mark:  # 检测到环
            return False
        if node not in visited:
            temp_mark.add(node)
            for next in graph.get(node, []):# 如果没有下一个节点，则不返回，例如D返回True；
                if not dfs(next):   
                    return False   
            temp_mark.remove(node)
            visited.add(node)
            stack.append(node)  # 确保所有邻居处理完后再加入栈
        return True

    for node in graph:
        if node not in visited:
            if not dfs(node):
                return []  # 如果检测到环，返回空列表

    return stack[::-1]  # 返回逆序的栈


# 示例用法
if __name__ == "__main__":
    graph = {"A": ["C", "B"], "B": ["D"], "C": ["B", "D"], "D": []}
    result = topological_sort(graph)
    print(result)  # 输出: ['A', 'B', 'C', 'D'] 或其他合法顺序
```

**逆拓扑排序：** 就是将DAG图中的*活动*按从后向前的顺序进行排序。

逆拓扑排序的一个基本实现思路：

1. 从AOV网中选择一个没有前驱(出度为0)的顶点并输出。
2. 从AOV网中删除该顶点以及与之相连的有向边。
3. 重复1、2直到AOV网为*空*或*当前网中不存在出度为0的顶点为止*

![image-20220521140116399](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095907374-169452500.png)

## 7.11 关键路径

![image-20220521142352922](F:\learning\os_review\数据结构\assets\2616061-20230217095904740-1977329790.png)

在AOE网中，仅有一个入度为0的顶点，称为开始顶点(源点)，表示整个工程的开始。也仅有一个出度为0的顶点，称为结束顶点(汇点)，表示整个工程的结束。

**关键路径：**从源点到汇点的有向路径可能存在多条，其中路径长度最长的称为关键路径，关键路径上的活动称为关键活动。关键路径长度决定了完成这项工程所需要的最短时间。

![image-20220521143837118](F:\learning\os_review\数据结构\assets\2616061-20230217095906074-1905087447.png)

❓如何找到AOE图中的关键路径？答：先找到AOE图中的关键活动。

❓那么如何找到关键活动呢？答：关键活动的最早开始时间和最迟开始时间应该相同，我们可以借助这个性质来找到关键活动。步骤如下：

1. 求所有事件(顶点)的最早发生时间`ve()`

   ![image-20220521150407068](F:\learning\os_review\数据结构\assets\2616061-20230217095906055-1007960337.png)

2. 求所有事件的最晚发生时间`vl()`

   ![image-20220521150521582](F:\learning\os_review\数据结构\assets\2616061-20230217095904744-583506267.png)

3. 求所有活动(边)的最早发生时间`e()`

   ![image-20220521150642602](F:\learning\os_review\数据结构\assets\2616061-20230217095907367-173821188.png)

4. 求所有活动的最晚发生时间`l()`

   ![image-20220521150738600](F:\learning\os_review\数据结构\assets\2616061-20230217095905815-1871488077.png)

5. 求所有活动的时间余量`d() = l() - e()`，余量为0的活动就是关键活动。

**关键路径、关键活动特性:**

* 若关键活动耗时增加，则整个工程的工期将增长。
* 缩短关键活动时间，可以算短工期。
* 当缩短到一定程度时，关键活动可能会变成非关键活动
* 一个工程可能有多个关键路径，此时要缩短工期，需要加快所有关键路径上的关键活动才能达成目的

# 第八章 查找

## 8.1 分块查找

![image-20220523155758843](F:\learning\os_review\数据结构\assets\2616061-20230217095906136-714129932.png)\
\
![image-20220523161326848](F:\learning\os_review\数据结构\assets\2616061-20230217095906279-1409997001.png)

## 8.2 B树

### 8.2.1 B树的由来：

解决AVL树读取文件时的I/O操作，具体见

### 8.2.2 B树的定义

![image-20220523171215789](F:\learning\os_review\数据结构\assets\2616061-20230217095906682-1205275791.png)

**注：**

- 第三点用于保证结点中的关键字数量更多，进而提高查找效率
- 第五点保证了B树的高度。
- 注意区分关键字个数和结点个数。
- 有n个关键字，就有n+1个叶节点（插空法）

n叉查找树的结点定义：

```c++
struct Node {
    ElemType key[n-1]; // 最多n-1个关键字
    struct Node *child[n]; // 最多n个孩子
    int num; // 记录结点中有几个关键字
}
```

### 8.2.2 核心特性

![image-20220523171645045](F:\learning\os_review\数据结构\assets\2616061-20230217095906932-1310463276.png)

关于结论的推导，记住两个极限形式，最少结点或者最多结点。

### 8.2.3 B树的插入删除操作

参考这篇文章：[B树、B+树详解 - Assassinの - 博客园 (cnblogs.com)](https://www.cnblogs.com/lianzhilei/p/11250589.html)

## 8.3 B+树

![image-20220525103044701](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906576-1522269834.png)

* 在B+树中，无论查找成功与否，最终一定都要走到最下面一层结点。

![image-20220525142314940](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906955-1043762812.png)

## 8.4 散列查找

**散列表(hash table)**，又称哈希表。是一种数据结构，特点是：数据元素的关键字与其存储地址直接相关。

解释一下就是：数据元素的存储地址是由关键字借助哈希函数计算得到的。

* 不同的关键字通过散列函数映射到同一个值，则称它们为“同义词”
* 通过散列函数确定的位置已经存放了其他元素，则称这种情况为“冲突”

**常见的散列函数：**

1. **除留余数法**：$H(key) = key % p$。如果散列表表长为m，取一个不大于m但最接近或等于m的*质数*p。

   为什么要选择质数呢？因为用质数取模，分布更均匀，冲突更少。

2. **直接定址法**：$H(key)=key或H(key)=a*key+b$。这种方法适合关键字分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。

3. **数字分析法**：选取数码分布较为均匀的若干位作为散列地址。

4. **平方取中法**：取关键字的平方值的中间几位作为散列地址。

这几个方法的主要目标是为了构造 **均匀分布的数列**

**处理冲突的方法：**

1. **拉链法**

   ![image-20220525151908610](F:\learning\os_review\数据结构\assets\2616061-20230217095906702-1158151649.png)

   $装填因子=\dfrac{表中记录数a}{散列表长度n}\\$，装填因子其实也等于查找失败时的平均查找长度。装填因子的大小会直接影响散列表的查找效率。

2. **开放定址法**

   ![image-20220525153503706](F:\learning\os_review\数据结构\assets\2616061-20230217095906665-1254780200.png)

   * 线性探测法：

     当发生冲突时，每*次往后探测相邻的下一个单元*是否为空。线性探测法很容易造成**同义词、非同义词的“堆积”现象，严重影响查找效率**。

     **注意：** 采用“开放定址法”时，删除结点不能简单地将被删结点的空间置为空，否则将截断它在之后填入散列表的同义词结点的查找路径。可以在删除结点时做一个“删除标记”，进行逻辑删除。

     ![image-20220525170352833](F:\learning\os_review\数据结构\assets\2616061-20230217095906677-1998281384.png)

   * 平方探测法：

     ![image-20220525170846666](F:\learning\os_review\数据结构\assets\2616061-20230217095907662-675990936.png)

     使用平方探测法时，散列表的长度m必须是一个可以表示成$4j+3$的素数，才能探测到所有位置。

   * 伪随机序列法：

     ![image-20220525171616994](F:\learning\os_review\数据结构\assets\2616061-20230217095907986-2007231827.png)

3. **再散列法**

   ![image-20220525171742110](F:\learning\os_review\数据结构\assets\2616061-20230217095907992-1093894103.png)

**注：**

1. 查找时一定注意范围，一定是**散列函数取到的范围，而不是以表长为准**；
2. 在删除元素的同时，注意**删除是逻辑删除，而不是物理删除**(这样可以确保不破坏其他的查询结果)
3. 哈希表的删除由于是逻辑删除，导致一个很奇怪的结果就是哈希表的存的"很满"，但是很多位置未利用。
4. 查找时一定一定要走完全程，或者走到空指针处。
5. 装填因子$\alpha$的注意事项：
   - $\alpha↑,冲突概率↑,查找效率⇃$
   - 装填因子不是越小查找效率就越高（例如我可以在一个哈希表后追加很多个连续空间，但是散列函数取不到）。
   - 装填因子直接影响平均查找长度ASL。

## 8.5 红黑树

1.出现原因：由于平衡二叉树在插入或者删除时会频繁修改树的拓扑结构，因此需要**放宽一些限制**，引入了红黑树。

2.红黑树的性质：

- **每个结点要么是红色，要么是黑色**
- **根节点是黑色的**
- **叶节点也是黑色的**
- **不存在两个相邻的红结点**
- 对每个结点来说，从该结点到**任意一个结点**的**简单路径上**，所含黑结点的个数相同。

速记：
**左根右，根叶黑，不红红，黑路同（黑高）**

3.基本数据结构定义如下：

```c++
typedef struct node{
   int key;
   ptr* parent;  // 父亲指针
   ptr* lchild;
   ptr* rchild;
   int color;
}Node;
```

4.常用结论：

- 从根到叶结点的最长路径不大于最短路径的2倍。（推导见书上）
- n个结点，红黑树的高度为$h<=2log_2(n+1)$​

5.红黑树的插入（关键是不能破坏**不红红这个条件**）

![image-20250419105452603](F:\learning\os_review\数据结构\assets\image-20250419105452603.png)





# 第九章 排序

排序这一章可以结合这篇文章进行学习：[十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)](https://www.cnblogs.com/onepixel/articles/7674659.html)

## 9.1 基本概念

**算法的稳定性：** 假设待排序表中有两个元素$(a,b)$它们的值相同，且a排在b之前，如果排序之后，a仍然排在b之前，就说这个算法具有稳定性。

**内部排序：** 数据都存放在内存中，进行排序。

**外部排序：** 数据太多，无法全部放入内存，需要借助外存进行排序。

## 9.2 插入排序

**算法思想：** 每次将一个待排序的记录按照关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成。

**时间复杂度：**

* 最好时间复杂度(全部有序)：$O(n)$ ，数组基本上有序
* 最坏时间复杂度(全部逆序)：$O(n^2)$
* 平均时间复杂度：$O(n^2)$​

**初始序列的排列方式会影响时间复杂度**

**空间复杂度**

- $O(1)$, 仅使用了常数个辅助单元

**算法稳定性：**稳定

```c++
void InsertSort(int A[], int n) {
    int i, j, temp;
    for (i = 1; i < n; i ++) {
        if (A[i] < A[i - 1]) {
            temp = A[i];
            for (j = i - 1; j >= 0 && A[j] > temp; j --) {
                A[j + 1] = A[j];
            }
            A[j + 1] = temp;
        }
    }
}
```

**折半插入排序：**

1. 在查找插入位置的时候，可以采用折半查找的方式来进行，将关键字比较的时间复杂度降低到$O(log_2n)$
2. 但是总的时间复杂度没有改变（关键字移动仍然是$O(n)$ 总体情况就为$O(n^2)$
3. 和插入排序一样，该算法仍然是稳定的算法

**简单插入排序的性质:**

1. 每次排序后，**不一定能够保证每个关键字在其最终位置**
2. 每一趟的排序结果，**数组的前半部分是一定有序的**
3. 适用于基本上已经有序的序列
4. 采用**链式存储的方式无需移动元素**，但时间复杂度仍然为$O(n^2)$​

## 9.3 希尔排序

**希尔排序的基本思想是：**先追求表中元素的部分有序，再逐渐逼近全局有序。

![image-20220526155046266](F:\learning\os_review\数据结构\assets\2616061-20230217095906699-1941945136.png)

**希尔排序的大体过程：**

1. 确定增量d(也就是间隔)，按照增量d将原表拆分成多个子表,一般来说取4，2，1
2. 对每个子表进行插入排序
3. 缩小增量d(一般对半缩)，重复操作，直到d=1

![image-20220526155539820](F:\learning\os_review\数据结构\assets\2616061-20230217095906706-2011027792.png)

**时间复杂度：**

* 最坏时间复杂度：$O(n^2)$    **d=1时，退化成直接插入排序**
* 平均时间复杂度：未知，但优于直接插入排序

**算法稳定性：**不稳定

**算法适用性：** 仅适用于顺序表

```c++
void ShellSort(int A[], int n) {
    int d, i, j;
    // 用A[0]来暂存数据
    for (d = n/2; d >= 1; d/=2) {
        for (i = d+1; i <= n; i ++) {
            if (A[i] < A[i - d]) {
                A[0] = A[i];
                for (j = i - d; j > 0 && A[0] < A[j]; j -= d) {
                    A[j + d] = A[j];
                }
                A[j + d] = A[0];
            }
        }
    }
}
```

## 9.4 冒泡排序

**算法思想：** 从后往前(或从前往后)两两比较相邻元素的值，若为逆序，则交换它们，直到序列比较完。称这样的过程为“一趟”冒泡排序

（基于交换的排序）

**时间复杂度：**

* 最好时间复杂度：$O(n)$ 序列顺序排列
* 最坏时间复杂度：$O(n^2)$ 序列逆序排列
* 平均时间复杂度：$O(n^2)$​

**空间复杂度**：

- $O(1)$ 仅使用了常数个的变量

**算法稳定性：**稳定

**算法适用性：** 适用于顺序表和链表

```c++
void BubbleSort(int A[], int) {
    for (int i = 0; i < n - 1; i ++) {
        bool flag = false;
        for (int j = n - 1; j > i; j --) {
            if (A[j] < A[j - 1]) {
                swap(A[j], A[j-1]);
                flag = true;
            }
        }
        if (flag == flase) { // 如果本趟冒泡未发生交换，就说明序列已经有序。
            return;
        }
    }
}

void swap(int &a, int &b) {
    int temp;
    temp = a;
    a = b;
    b = temp;
}
```

**性质：**

1. 每次排序后，一定有一个元素在其最终位置。
2. 时间复杂度集中在比较元素的次数上，故如果序列基本有序，能够很好的降低时间复杂度
3. 一般来说，乱序的比较次数为$O(n(n-1)/2)$, 移动次数为$O(3n(n-1)/2)$

## 9.5 快速排序

**快速排序的基本思想：**通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。(**典型的分治思想**)

快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。**具体算法描述如下**：

* 从数列中挑出一个元素，称为 “基准”（pivot）；
* 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
* 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

**时间复杂度：**

* 最好时间复杂度：$O(nlog_2n)$ 每次选的枢轴元素都能将序列划分成均匀的两部分
* 最坏时间复杂度：$O(n^2)$ 若序列原本就**有序或逆序**，则时间、空间复杂度最高
* 平均时间复杂度：$O(nlog_2n)$​

**空间复杂度：**

- 最好情况：$O(log_2n)$  **平分秋色** ，递归调用栈的深度
- 最坏情况：$O(n)$    递归调用栈的深度
- 平均 $O(log_2n)$

**算法稳定性：**不稳定

**执行流程：**

1. high指针用于找到数组右边小于枢纽的元素
2. high指针找到，与low指针进行交换
3. 接下来low指针移动，找到比枢纽大的元素
4. 找到了与high指针交换
5. 重复1~4步骤，最后low和high相等时即为枢纽元素的最终位置

```c++
void quickSort(int A[], int low, int high) {
    if (low < high) {
        int p = partition(A, low, high); // 划分
        quickSort(A, low, p - 1);  // 递归划分左子表
        quickSort(A, p + 1, high);  // 递归划分右子表
    }
}

int partition(int A[], int low, int high) {
    int temp = A[low]; // 确定枢轴
    while (low < high) {
        while (low < high && A[high] >= temp) {
            high --;
        }
        A[low] = A[high]; // 找到比枢轴小的元素，并移动到左端
        while (low < high && A[low] <= temp) {
            low ++;
        }
        A[high] = A[low];  // 找到比枢轴大的元素，并移动到右端
    }
    A[low] = temp;
    return low; // 返回最终枢轴的存放位置
}
```

**快排的优化思路：**关键在于枢轴元素的选取，要尽量选择可以把数据中分的枢轴元素。

* 可以选择头、中、尾三个位置的元素，取中间值作为枢轴元素。
* 随机选一个元素作为枢轴元素。

**性质：**

1. 快排每次结束后，**必有一个结点在其最终位置，且块间有序**(同冒泡排序)
2. 如果每次枢纽元素将数组划分得很均匀，则空间和时间复杂度最佳
3. 快速排序是**所有内部排序算法中平均性能**最优的算法
4. **数组基本有序时，快速排序可能退化为冒泡排序**

## 9.6 简单选择排序

**选择排序：** 每一趟在待排序元素中选取关键字最小或最大的元素加入到有序子序列中

**时间复杂度：** $O(n^2)$

**稳定性:** 不稳定,简单排序中就它不稳定

**适用范围：**顺序存储和链式存储的线性表，以及关键字较少的情况

```c++
void selectSort(int A[], int n) {
    for (int i = 0; i < n - 1; i ++) {
        int min = i;
        for (int j = i + 1; j < n; j ++) {
            if (A[j] < A[min]) {
                min = j
            }
        }
        if (min != i) {
			int temp = A[i];
        	A[i] = A[min];
        	A[min] = temp;
        }
    }
}
```

**性质：**

1. 简单选择排序的时间复杂度**主要集中在比较上**，因此不论怎么修改，时间复杂度总是$O(n^2)$
2. 基于上述性质，可以得知选择排序不受到初始序列的排列影响
3. 同样，该排序每次运行完能够确定一个元素在其最终位置上

## 9.7 堆排序⭐

**总览：**

![image-20220527150938125](F:\learning\os_review\数据结构\assets\2616061-20230217095906742-1665439563.png)

**堆排序：**

将一个数组初始化成堆，每次输出堆顶元素，同时不断调整已输出的堆，直到所有元素输出完，排序结束

**堆：**

满足**父节点大于等于（小于等于）两个子节点的完全二叉树**，我们称之为堆（大顶堆小顶堆）

通常我们以一个数组来存放堆

例如

![img](F:\learning\os_review\数据结构\assets\6849cd0420510cef521e1fd6c6189272.png)

**初始堆的构建：**

 1.从最后一个非终端结点进行调整，若左右孩子发现不满足条件，则与父节点进行交换

2.这样依次进行，最后执行到根节点

3.注意每次交换时，要注意已经修改好的结点（例如下半部分的结点）

![](F:\learning\os_review\数据结构\assets\953680-20200531004135177-1000133948.png)

实现代码如下（大顶堆）：

```c++
void buildheap(Elem A[],int len)
{
    for(int i=len/2;i>0;i--)   // 从非叶节点开始调整
    {
        heapadjust(A,i.len);
    }
}
void heapadjust(Elem A[],int k,int len)
{    // 调整以K为根的子树
    A[0]=A[k];    // 哨兵结点
    for(int i=2*k;i<=len/2;i*=2)
    {
        if(i<len&&A[i]<A[i+1])   // 比较左右子树元素谁大
            i++;
        if(A[0]>=A[i])
            break;
        else                    // 进行结点交换
        {
            A[k]=A[i];
            k=i;
        }
    }
    A[k]=A[0];   // 放入最终位置
}
```

**堆的插入：**

与堆的构建类似，将要插入的元素放在数组末尾，然后向上面的算法一样进行调整



**堆的删除：**

将堆顶的元素和末尾的元素进行对调，然后忽视堆顶的元素，最后用同样的方法继续调整堆



**堆操作的时间复杂度分析：**

Hint：层数为i的结点，**其堆的调整次数不超过$2(h-i)$, 其中h为堆的高度**

**建堆时间分析：**$O(n)$ ,可以证明，一个无序数组构建成一个堆的调整次数不超过4n；

**堆调整时间：**每次插入或者删除，调整时间复杂度为$O(log_2n)$



**堆排序：**

基于已建立好的堆，每次输出顶结点即可,同时调整堆的形态

实现代码如下：

```c++
void Heapsort(Elem A[],int len)
{
    buildheap(A,len);
    for(int i=len;i>1;i--)
    {
        swap(A[i],A[1]);
        heapadjust(A,i,i-1);
    }
}
```

**时间复杂度分析：**

- 最好 $O(log_2n)$  最坏$O(log_2n)$  平均 $O(log_2n)$  由于堆的高为$log_2n$

**空间复杂度分析:**

- $O(1)$, 仅用了常数个变量

**稳定性：不稳定**

**适用范围：** 仅仅适用于顺序存储的线性表

**性质：**

1. 同样，堆排序每次输出结果，必定有一个元素在其最终位置
2. 适用于寻找第k大元素

注意关键字的比较次数

## 9.8 归并排序

**基本思想：**归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

**时间复杂度：** $O(nlog_2n)$

**空间复杂度**：$O(n)$ ,仅使用了一个辅助数组

**稳定性：** 稳定

![image-20220527153718515](F:\learning\os_review\数据结构\assets\2616061-20230217095906778-418441137.png)

```c++
int *B = (int *)malloc(n * sizeof(int)); // 辅助数组B

void Merge(int A[], int low, int mid, int high) {
    int i, j, k;
    for (k = low; k <= high; k ++) {
        B[k] = A[k];
    }
    for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k ++) {
        if (B[i] < B[j]) {
            A[k] = B[i ++];
        } else {
            A[k] = B[j ++];
        }
    }
    while (i <= mid) A[k ++] = B[i ++];
    while (j <= high) A[k ++] = B[j ++];
}

void MergeSort(int A[], int low, int high) {
    if (low < high) {
        int mid = (low + high) / 2;
        MergeSort(A, low, mid);
        MergeSort(A, mid + 1, high);
        Merge(A, low, mid, high);
    }
}
```

**性质：**

1. 每趟归并的时间复杂度为$O(n)$   相当于每个元素都遍历了一遍
2. 2路归并可以看作一个二叉树，第一次归并为倒数第一层 到 倒数第二层 故我们可以通过排序元素个数确定归并趟数 ，例如结点有n个，那么与高度的关系有$2^{h-1}>=n $ ,可以推得  高度为$\lceil{log_2n}\rceil$​
3. 适用于链式存储或者顺序存储

## 9.9 基数排序

**基本思想：**基数排序是一种非比较式的排序算法。它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

**时间复杂度：** $O(d(n+r)$ 其中一趟分配耗时$O(n)$，一趟收集耗时$O(r)$​

**空间复杂度：**$O(r)$ 用了r个辅助队列进行排序；

**稳定性：** 稳定

**基数排序擅长解决的问题：**

* 数据元素的关键字可以方便的拆分成d组，且d较小。
* 每组关键字的取值范围不大，即r较小。
* 数据元素个数n较大。

![image-20220601181037506](F:\learning\os_review\数据结构\assets\2616061-20230217095908072-312046872.png) ![image-20220601181114650](F:\learning\os_review\数据结构\assets\2616061-20230217095908106-1962092506.png) ![image-20220601181144183](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095908330-2098615101.png)

## 9.10 计数排序

**定义：**计数排序是一种不基于比较的算法，其通过统计关键字出现的**频率**，计算出相比于该关键字小于等于的元素个数，进而进行排序

```c++
void countsort(elem A[],elem B[],int n,int k)
{
    int i,C[k];        // k表示元素最大值
    for(int i=0;i<k;i++)
    {
        C[k]=0;                   // 初始化计数数组c
    }
    for(int i=0;i<n;i++)
    {
        C[A[i]]++;            // 统计关键字出现的频率
    }
    for(int i=1;i<k;i++)
    {
        C[i]=C[i]+C[i-1];      // 保存小于等于关键字的元素个数
    }
    for(int i=n-1;i>=0;i--)
    {
        B[C[A[i]]-1]=A[i];        // 从后往前遍历整个数组（保证其排序时的稳定性）
        C[A[i]]=C[A[i]]-1;        // 将元素放在B的正确位置
    }
}
```

**时间复杂度：**$O(n+k)$  其中k为辅助数组的长度（也就是数组中不同元素的个数)，若其规模达到了$log_2n$，效果不如一些其他排序算法

**空间复杂度：**$O(k)$ ,  辅助数组的长度。

## 9.11 外部排序

**外部排序**是当数据量很大，内存空间不足以全部存放时，对数据进行排序的方式。由于操作系统是以块为单位对磁盘空间进行管理的，所以我们可以一次读入多个块进入内存进行排序，然后将结果写入到磁盘中，多次重复这种操作，就可以实现大量数据的排序。通常，在外部排序时，会采用归并排序的思想。

**外部排序流程：**

1. 根据内存缓冲区的大小，将外存的上下文分成若干个长度为L的子文件，然后在内存中用内部排序的算法进行排序，然后将排序完的子文件写入到磁盘中
2. 对已经分好的子文件进行归并排序，使得文件逐渐从小到大，直到有序为止

![image-20220601185836570](F:\learning\os_review\数据结构\assets\2616061-20230217095908216-1207063061.png) ![image-20220601190114001](F:\learning\os_review\数据结构\assets\2616061-20230217095908403-1774963964.png)

**补充：** 什么是多路平衡归并？

k路平衡归并，需要满足以下两个条件：

1. **最多只能有k个段归并为一个段**
2. 在每一趟归并中，若有m个归并段参与归并，则处理之后的归并段个数需满足：$(n =\lceil \frac{m}{k} \rceil)$

![image-20220601190526233](F:\learning\os_review\数据结构\assets\2616061-20230217095908354-1399592103.png)\
上面这个是四路平衡归并
![image-20220601190601421](F:\learning\os_review\数据结构\assets\2616061-20230217095906711-247249225.png)\
上面这个是四路归并，但不是四路平衡归并

**败者树：**

![image-20220601193002635](F:\learning\os_review\数据结构\assets\2616061-20230217095906837-1153121374.png) ![image-20220601192931643](F:\learning\os_review\数据结构\assets\2616061-20230217095906984-813827455.png)

**置换-选择排序：**

![image-20220601194112076](F:\learning\os_review\数据结构\assets\2616061-20230217095906672-1730833343.png) ![image-20220601194021721](F:\learning\os_review\数据结构\assets\2616061-20230217095906760-352224696.png) ![image-20220601194037004](F:\learning\os_review\数据结构\assets\2616061-20230217095906804-1898659157.png) ![image-20220601194052979](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906680-154027337.png)

**最佳归并树：**

![image-20220601231954684](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906843-1739086752.png) ![image-20220601232049385](https://img2023.cnblogs.com/blog/2616061/202302/2616061-20230217095906790-1979399704.png) 

