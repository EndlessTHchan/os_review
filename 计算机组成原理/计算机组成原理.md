[toc]

# 计算机组成原理

## **第一章 计算机系统概述：**

### 1.计算机系统的组成：

![](./asset/image-20250511152231292.png)

常见的软件分类有：

1. 系统软件：操作系统、数据库管理系统DBMS、标准程序库、网络软件系统、语言处理程序
2. 服务性程序、编译程序、连接程序、分布式软件系统
3. 应用软件：微信、QQ、数据库软件DBS



- 一般来说，软件的功能和硬件的功能是可以相互替代的，硬件效率高，实现复杂，软件简单但效率低



### 2.计算机系统的发展：

![image-20250511153814022](F:\learning\os_review\计算机组成原理\asset\image-20250511153814022.png)



### 3.计算机硬件组成：

![image-20250511153444389](./asset\image-20250511153444389.png)

上图为冯诺伊曼结构：以**运算器为中心（运算器负载高，压力大）**

特点：①计算机硬件系统由五大部件组成
	 ②**指令和数据都是以同等地位存于存储器，可按地址寻访，指令是顺序执行的**
	③指令和数据用二进制表示
	④指令由操作码和地址码组成 
	⑤**采用"存储程序"的工作方式**

冯氏结构的设计主要是以一种**控制流驱动的工作方式**进行的，即我给你把步骤安排好了，只需要按照这个控制流程走下去就行。



现代计算机则优化了这一结构，以存储器为中心

![image-20250511155345735](F:\learning\os_review\计算机组成原理\asset\image-20250511155345735.png)

![image-20250511155503643](F:\learning\os_review\计算机组成原理\asset\image-20250511155503643.png)

功能简介：

- ALU:用于算数运算和逻辑运算
- 主存储器：与cpu直接交换信息（交换信息有媒介的，不要搞混了 **内存—>cache—>寄存器**）
- 外部设备：输入输出设备，将输入内容转化为计算机所知道的，同时输出时将二进制转化为人所知道的。



### 4.计算机软件：

![image-20250511160049846](F:\learning\os_review\计算机组成原理\asset\image-20250511160049846.png)

注意数据库这种特殊的系统软件，以及编译器，解释器这种用于程序翻译的系统软件。

程序在系统中被转化的流程：

![image-20250511160259884](F:\learning\os_review\计算机组成原理\asset\image-20250511160259884.png)

整个过程经过了：

1. 预处理：将c文件中的一些注释等其他东西进行删除，同时进行宏替换，把一些头文件内容复制进来等一系列操作。
2. 编译：将c语言转化为汇编语言（**根据ISA架构转化为相应的汇编内容**，arm转arm的汇编，x86转x86的汇编）
3. 汇编：将汇编语言转换为机器可执行的二进制代码
4. 链接：将多个二进制代码模块串起来，形成一个完整的可执行文件。

详细的程序内存分配以及地址映射见程序装载部分（OS)



### 5.计算机系统的结构层次

**分层原因：**计算机是一个非常复杂的系统，为了**简化对计算机系统的研究和实现**，可以采用分层思想将计算机划分成多个层次的系统。

同计算机网络分层效果，**下一层为上一层提供一个简洁抽象的接口，屏蔽了内部实现过程。是透明的。**

各大分层都没有明确规定，这里给出了一个分层参考方案：

![image-20250511161710114](F:\learning\os_review\计算机组成原理\asset\image-20250511161710114.png)

注意这里的考题，容易问你，哪类程序员在哪一层（也就是他应该知道哪一层的内容，而对其他层的内容不了解），**在 CPU 的寄存器中，指令寄存器对用户是完全透明的** 。



### 6.计算机的工作原理

![image-20250511163033927](F:\learning\os_review\计算机组成原理\asset\image-20250511163033927.png)

接上文的内容，我们这次来详细讲讲各个硬件的详细组成：

#### 1.运算器:

1. 构成：ALU ，ACC(累加寄存器)， MQ乘商寄存器,  X操作数寄存器， PSW状态寄存器，移位器、计数器、变址寄存器IX、基址寄存器BR （后面这几个到寻址部分再来讲述）

   算术逻辑单元ALU：
   通过内部复杂的电路实现**算数运算、逻辑运算**

   累加寄存器ACC：
   用于**存放操作数，或运算结果**

   乘商寄存器MQ：
   在乘、除运算时 ，用于存放操作数或运算结果

   操作数寄存器X：
   用于存放操作数 

   状态寄存器PSW：
   存放ALU运算得到的一些标志信息或处理机的状态信息，OF, ZF ,SF, CF

以图表的形式展示如下：

![image-20250511163502704](F:\learning\os_review\计算机组成原理\asset\image-20250511163502704.png)

#### 2.控制器：

1. 构成：CU、IR、PC、指令译码器(地址译码器在内存中)、时序系统、微操作信号发生器(后面几个涉及到数据寻址以及cpu构成的时候再来讨论)

2. 工作原理：

   控制单元 CU：分析指令，给出控制信号 

   指令寄存器 IR：存放当前执行的指令 **(IR中的内容来源于主存的MDR)**

   程序计数器 PC：存放下一条指令地址，有**自动加一**功能**（PC与主存的MAR之间有一 条直接通路）**

3. 注意事项：

   CPU 区分指令和数据的依据：1.指令周期的不同阶段（**在取指令阶段取出的为指令、在 执行指令阶段取出的即为数据**）2.通过地址来源区分 （**由PC提供存储单元地址取出的是指令、由指令地址码部分提供存储单元地址取出的是操作数**）

#### 3.存储器：

1. 构成：存储体、MAR,MDR（现代计算机为了加速计算，将这俩都放在cpu中）

2. 工作原理：存放二进制信息。 

   存储单元——每个存储单元存放一串二进制代码   存储字——存储单元中二进制代码的组合

    存储字长——存储单元中二进制代码的位数

    存储元——存储二进制的电子元件，每个存储元可存1bit MAR ： 存放访存地址，经过地址译码后找到所选的存储单元。 MAR位数反应存储单元的个数 【 MAR=4 位 ——> 总共有 24 个存储单元】 MDR ： 用于暂存要从存储器中读或写的信息。 =16bit 】 MDR位数=存储字长 【 MDR=16 位 ——> 每个存储单元可存放 16bit ，一个字 一个字节 =8bit ， 1B= 一个字节， 1b=1bit ，字由计算机硬件决定 。 时序控制逻辑：用于产生存储器操作所需的各种时序信号。

#### 4.工作过程：

![image-20250511184334225](F:\learning\os_review\计算机组成原理\asset\image-20250511184334225.png)7



### 7.计算机性能指标：

#### 1.机器字长：

字长：CPU内部用于整数运算的数据通路的宽度。（字长=CPU内部用于整数运算的运算 器位数=通用寄存器宽度） 

字：表示被处理信息的单位。不同机器的字的位数可能不同。 

机器字长：**计算机进行一次整数运算所能处理的二进制的位数**。 

指令字长：一个指令中二进制的位数 

存储字长：存储单元中二进制的位数(MDR)。指令字长一般为存储字长的整数倍。

#### 2.数据通路带宽：

hint: 这里的带宽是指的外部数据总线的宽度。而不是cpu内部总线的

数据通路带宽——**数据总线一次所能并行传送信息的位数**。

#### 3.主存容量：

$容量 = 存储单元个数 * 存储字长 （bit） = 存储单元个数 * 存储字长 / 8 （Byte）$

e. g   $MAR为32位，MDR为8位，总容量=232 * 8bit = 4GB$

#### 4.运算速度：

##### 1.吞吐量：

系统在单位时间内处理请求的数量，主要取决于主存的存取周期

##### 2.响应时间：

与操作系统中介绍的响应时间类似，**用户发出请求时间，到该请求被处理完的等待时间**

##### 3.cpu时钟周期：

每个脉冲信号的时间称为CPU时钟周期。**CPU工作的最小时间单位。**

![image-20250511190029089](F:\learning\os_review\计算机组成原理\asset\image-20250511190029089.png)

##### 4.CPI:

定义：**执行一条指令所需要的时钟周期数量**。

![image-20250511190219326](F:\learning\os_review\计算机组成原理\asset\image-20250511190219326.png)

注意一条指令的cpi和一类指令的cpi。一个通过测试得到，另一个是要加权平均的。

##### 5.cpu执行时间：

是cpu真正用于执行用户程序的执行时间。

定义为  $ cpu执行时间 = 程序执行所需要的时钟周期数量 * 时钟周期$

通常这里容易结合cpi来考，可参考下面例题。

![image-20250511190753276](F:\learning\os_review\计算机组成原理\asset\image-20250511190753276.png)

##### 6.IPC

每个时钟周期能够执行的指令数量。

由定义可知，cpi的倒数就是ipc，由于现在的流水线技术的发展，现在的ipc值已经可以大于1了。

##### 7.MIPS

每秒执行多少百万条指令。

![image-20250511191109171](F:\learning\os_review\计算机组成原理\asset\image-20250511191109171.png)

比较方式有点不准确，因为有些机器的架构和指令集设置不同，导致每台机器处理指令的速度不同。

##### 8.MFLOPS

每秒执行多少百万次浮点运算。

![image-20250511191308257](F:\learning\os_review\计算机组成原理\asset\image-20250511191308257.png)

能够反映浮点计算能力，但是不能反映整体性能。

tip：注意这里的单位换算。

**在描述文件大小、存储容量的时候，K、M、G、T通常认为是2的次方** 

**在描述速率、频率的时候，K、M、G、T通常认为是10的次方**



### 8.几个专业术语

系列机：具有**基本相同的体系结构**，使用相同基本指令系统的多个不同型号的计算机组 成的一个产品系列。 

兼容：指软件或硬件的通用性，即运行在某个型号的计算机系统中的硬件/软件也能应 用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上存在兼容性。 

软件可移植性：把使用在某个系列计算机中的软件直接或进行很少的修改就能运行在另 一个系列计算机中的可能性。 

固件：将程序固化在ROM中组成的部件。（**固件是具有软件特性的硬件，例如bios**）（执行速度 快于软件、灵活性快于硬件）





## **第二章 ： 数据的表示**

### 1.进制转换

基数： 每个数码位所用到的不同符号的个数，r进制的基数为r 。

二进制转十进制：101.1——>1 * 22 + 0 * 21 + 1*21 + 1 * 2-1 = 5.5 

八进制转十进制：5.4——>5 * 80 + 4 * 8-1 = 5.5 

十六进制转十进制：5.8——> 5 * 160 + 8 * 16-1 = 5.5

**方法：整数部分直接除以基数取余，最后将余数结果倒着排列一遍，小数部分就直接乘以基数，如果得到的结果中，出现了整数部分为1，那么就写1，同时直接将整数位变为0，这样依次进行下去，直到结果为0，或者达到一定精度。**

![image-20250511192503010](F:\learning\os_review\计算机组成原理\asset\image-20250511192503010.png)

### 2.定点数的编码表示

#### 1.真值和机器数

- 真值：符合人类习惯的数字，计算机所代表的实际值。 
- 机器数：数字实际存到机器里的形式，正负号需要被“数字化”。

#### 2.机器数的定点表示

对于数据来说，有两种形式，一种整数，一种是小数。那么计算机来如何保存呢？

整数就用定点整数表示就好了，像小数，我们可以将其变成（定点整数+阶码），以浮点数的形式表示。

   定点表示法用来表示定点小数和定点整数。 

（1）定点小数：**定点小数是纯小数，即无整数部分**。小数点位置在符号位之后，最高有 效位之前。 

（2）定点整数：**定点整数是纯整数。小数点位置在最后**。

![image-20250511193124340](F:\learning\os_review\计算机组成原理\asset\image-20250511193124340.png)

### 3.原码，补码，移码，反码表示法：

#### 1.介绍：

 **原码**：由符号位和数值位组成，正数：  符号位为0：负数  符号位为1。   

 优点：①与真值对应关系简单、直观 ，**在计算机中只用于表示浮点数的尾码**  ②原码乘除运算简单  缺点：①0的表示不唯一 ②原码加减运算复杂

![image-20250511193950655](F:\learning\os_review\计算机组成原理\asset\image-20250511193950655.png)

![image-20250511194552716](F:\learning\os_review\计算机组成原理\asset\image-20250511194552716.png)





**反码：**由符号位和数值位构成，正数，符号位为0 ，且数值位为原码数值位，负数的符号位为1 ，且数值位为原码数值位取反。

一般来说用的比较少。

![](C:\Users\27147\AppData\Roaming\Typora\typora-user-images\image-20250511194657547.png)

![image-20250511194702204](F:\learning\os_review\计算机组成原理\asset\image-20250511194702204.png)





**补码：**

直接讲求法了（反转法）：若为正数，则和原码表示一样，若为负数，符号位为1，数值位按位取反，最后在末尾加1，注意特殊情况 (10000000,只为8位的时候，这个数为 -128，小数为 -1 ）

![image-20250511195101744](F:\learning\os_review\计算机组成原理\asset\image-20250511195101744.png)

![image-20250511195135616](F:\learning\os_review\计算机组成原理\asset\image-20250511195135616.png)

![image-20250511195247992](F:\learning\os_review\计算机组成原理\asset\image-20250511195247992.png)





**移码：**

求法：就把相应的补码的符号位取个反就是了。移码多用于表示阶码（整数）

![image-20250511195531617](F:\learning\os_review\计算机组成原理\asset\image-20250511195531617.png)

![image-20250511195547257](F:\learning\os_review\计算机组成原理\asset\image-20250511195547257.png)

![image-20250511195856388](F:\learning\os_review\计算机组成原理\asset\image-20250511195856388.png)

#### 2.相互转换：

扫描法：原码转换为补码的时候可以采用 符号位其他位按位取反，然后在末尾进行加1

反码法：先将原码转换为反码，然后再转换为相应的补码。



### 3.浮点数表示

#### 1.引言：

计算机中主要有两种保存方式，一种为纯小数（也就是定点小数）表示法，一种为整数表示（即定点整数），那么我们如果保存小数，则需要将其化为定点小数和定点整数的集合（类似科学计数法）

![image-20250513163016720](F:\learning\os_review\计算机组成原理\asset\image-20250513163016720.png)



为了计算机处理浮点数方便，我们规定：

![image-20250513163220739](F:\learning\os_review\计算机组成原理\asset\image-20250513163220739.png)

#### 2.浮点数的表示范围：

浮点数的真值： $N = (-1)^s * r^E * M$ **(基数越大、范围越大、 但精度变低)**

对应的，如果想求其范围，一般来说，取阶码和尾数的最大最小值即可。

![image-20250513180640408](F:\learning\os_review\计算机组成原理\asset\image-20250513180640408.png)



注意，一旦取到发生上溢，计算机会将该数置为 **无穷大或无穷小**，**发生下溢直接将数置为0**

![image-20250513180850438](F:\learning\os_review\计算机组成原理\asset\image-20250513180850438.png)

#### 3.浮点数的规格化

类似科学计数法，我们总不可能想出现$0.1*10^3$这种数字出来, 这个数的理论表示应该为$1.0*10^2$

这里我们举个例子，以阶码为移码表示，尾数为原码表示。

![image-20250513181335324](F:\learning\os_review\计算机组成原理\asset\image-20250513181335324.png)

规格化的好处：

- 使浮点数的表示形式唯一
- 使浮点数的表示精度最高

![image-20250513181445090](F:\learning\os_review\计算机组成原理\asset\image-20250513181445090.png)

如何操作，采用左规和右归就好了，这两个操作主要是根据尾数来的

![image-20250513181555027](F:\learning\os_review\计算机组成原理\asset\image-20250513181555027.png)

![image-20250513181839499](F:\learning\os_review\计算机组成原理\asset\image-20250513181839499.png)

注意：右规的时候，可能会导致阶码**上溢**，左规的时候可能会导致阶码**下溢**。同时右规可能会导致浮点数的舍入。

主要是让最高位首位为有效位，即为1，如果遇到补码形式的尾数，**其规格化后一定为1.0或0.1(第一个数为符号位)。**  如果遇到不熟悉的尾数，转化为原码的再来研究就好了，原码的数值位第一位一定为1。

e.g:

![image-20250513182904912](F:\learning\os_review\计算机组成原理\asset\image-20250513182904912.png)

#### 4.IEEE 754浮点数

定义：直接背吧，没什么好的 ，分32位和64位的😭

![image-20250513183136485](F:\learning\os_review\计算机组成原理\asset\image-20250513183136485.png)

**注意这里的隐藏的1，这个隐藏的1是不写出来的！！！！！！**，而且偏置常数为127

表示范围：

![image-20250513183422895](F:\learning\os_review\计算机组成原理\asset\image-20250513183422895.png)

注意这个表格挖坑的地方：

- 正0和负0都是阶码和尾数都为0，看清楚了！
- 阶码的取值 $1<=E<=254$, 一旦不属于这个范围，那就要注意了！
- 为非规格化数时，记得隐藏位的1没有了 为0.x开头
- 注意无穷大和NaN的区别**（尾数）**

e.g:
![image-20250513184626521](F:\learning\os_review\计算机组成原理\asset\image-20250513184626521.png)

e.g:

![image-20250513184650920](F:\learning\os_review\计算机组成原理\asset\image-20250513184650920.png)

### 4.移位：

一般来说，左移能够使数字扩大到原来的二倍，右移能使数字缩小为原来的$\frac{1}{2}$，溢出判断见上面的讲解。

#### 1.逻辑移位：

**针对对象** ：无符号数

**规则： 左移：高位移出，低位补0  右移 ： 低位移出，高位补0**

一般用于寄存器快速置数或者快速清0

#### 2.算数移位：

**针对对象：**有符号数

**规则：** 两种方法，一是带着符号位玩的，二是不带符号位玩的

**不带符号位的：**

![image-20250516184909808](F:\learning\os_review\计算机组成原理\asset\image-20250516184909808.png)

注意这里的溢出判断。是按照以前的最高位和现在的最高位进行比较得来的

**带符号位的移动：**

左移：高位移除，低位补0，移动前后符号位发生变化，则发生溢出

右移：低位移出，高位补符号位。

这种方法采用的比较多，cpu也是按照这种方式处理的

![image-20250516185313597](F:\learning\os_review\计算机组成原理\asset\image-20250516185313597.png)

#### 3.循环移位：

![image-20250516185453755](F:\learning\os_review\计算机组成原理\asset\image-20250516185453755.png)

**不带CF标志位的移动：**

举个例子：只是$x_0 -x_7$移动，不过每次移出的数字都要记录在CF中，CF中的数不参与移位

![image-20250516185706088](F:\learning\os_review\计算机组成原理\asset\image-20250516185706088.png)

左移的方式类似

**带CF标志位的移动：**

![image-20250516185911301](F:\learning\os_review\计算机组成原理\asset\image-20250516185911301.png)

移动方式就把CF算进移动数组，然后整体移动就行了





### 5.C语言中的数据类型转换：

#### 1.常见的关键字规定

老生常谈的东西了

| 类型      | 字长 | 表示形式 |
| --------- | ---- | -------- |
| float     | 4B   | IEEE 32  |
| short     | 2B   | 补码     |
| char      | 1B   | 补码     |
| int       | 4B   | 补码     |
| long      | 4B   | 补码     |
| long long | 8B   | 补码     |
| double    | 8B   | IEEE 64  |

double能够完美表示float

注意这里的unsigned 前缀 ，**unsigned一般用原码表示** 

一般来说，如果超出字段长度了，机器会将机器码的高位截断，而将低位保留。

而低字长转为高字长的部分，无符号数就进行**0拓展**，有符号数就进行**符号拓展**

相同字长的转换，保证机器码不变就行了

![image-20250516183503287](F:\learning\os_review\计算机组成原理\asset\image-20250516183503287.png)

举个例子：

![image-20250516183223000](F:\learning\os_review\计算机组成原理\asset\image-20250516183223000.png)

这里的short是无符号数，直接0拓展就好了

#### 2.整形向浮点型的转换

![image-20250516183901803](F:\learning\os_review\计算机组成原理\asset\image-20250516183901803.png)









## **第三章 3.数据的运算：**

### 1.补码的加法减法（定点数的加法减法）：

**1.运算方式：**

和平常的计算的方式一样，没啥特殊的。**该运算方式也可推广到两个无符号数的计算**
$$
[A_补]+[B_补]=[{A+B}_补]
\\
[A_补]-[B_补]=[{A-B}_补]=[A_补]+[-B_补]
$$
**2.溢出判断：**

由于计算机字长有限，故在计算时，超出表示范围的就导致溢出了。（这里建议回归机器码的数据的表示范围）

**方法1：**根据**操作数的符号位**和**运算结果的符号位**是否一致来判断，符号位相同，则不溢出，符号位不同，则溢出

一般来说，补码的加减法溢出的情况，都是**同号数相加才会溢出**

下面给一个例子展示：

![image-20250516191017195](F:\learning\os_review\计算机组成原理\asset\image-20250516191017195.png)

**方法2：**根据运算过程的**最高位数值位**的**进位于符号位**的进位一起判断

溢出判断公式为$C_F\oplus C_H$ ，若为1，则发生溢出。

不能判断哪种类型的溢出

![image-20250516191608891](F:\learning\os_review\计算机组成原理\asset\image-20250516191608891.png)

**方法3：**双符号位，增加了一个符号位：

![image-20250516191710864](F:\learning\os_review\计算机组成原理\asset\image-20250516191710864.png)

**方法4：采用一位符号位，直接进行判断：**

![image-20250516191955406](F:\learning\os_review\计算机组成原理\asset\image-20250516191955406.png)

附：一位全加器电路图：

![image-20250516192200559](F:\learning\os_review\计算机组成原理\asset\image-20250516192200559.png)

注意如何学会判断门电路的延迟

串行加法器的电路图如图所示：

![image-20250516192640040](F:\learning\os_review\计算机组成原理\asset\image-20250516192640040.png)

检测方法采用的讲述的第二种方法$C_F\oplus C_H$ ，

当sub=0 ，做加法，y不用取反，然后参与加法运算， sub=1时，做减法，求出 -y的补码，然后进行相加（sub线这里相当于$C_0$,提供了加1操作）

快速加法器(先行进位加法器)，降低了门延迟，提高了计算速度





### 2.无符号数的乘法（主要考察电路）：

基本思想：采用加法加上移位操作。例如每次乘完后将结果先右移一位，然后再继续乘接下来的数

![image-20250516193810034](F:\learning\os_review\计算机组成原理\asset\image-20250516193810034.png)

例子：在正式进行乘法之前，**ACC置0**，**每次根据乘商寄存器MQ的低位，来判断是否要加上X.** $C_n$控制这种操作有多少次，例如这里有4位小数，那么$C_n$就为4，每次计算后，都要进行移位

![image-20250516194507493](F:\learning\os_review\计算机组成原理\asset\image-20250516194507493.png)

整个执行过程如下图所示：

![image-20250516194729962](F:\learning\os_review\计算机组成原理\asset\image-20250516194729962.png)





### 3.原码的乘法计算方式

原码比无符号数多了一个符号位，因此可以将符号位和数值位分开进行处理：

符号位 异或一下就好了，数值位仍然借用无符号数的电路进行计算

整个计算流程如下：

其中的$C_{out}$是进位信号， $C_n$是计算次数

![image-20250516195430438](F:\learning\os_review\计算机组成原理\asset\image-20250516195430438.png)

